<!DOCTYPE html>
<html lang="zh_CN">
<head>
  <meta charset="utf-8" />
  <title>all - Node.js Manual &amp; Documentation</title>
  <link rel="stylesheet" href="res/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="res/sh.css" type="text/css" media="all"/>
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js Manual &amp; Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#synopsis_">Synopsis 概要</a></li><li><a href="#global_Objects_">Global Objects 全局对象</a><ul><li><a href="#global">global</a></li><li><a href="#process">process</a></li><li><a href="#require">require()</a></li><li><a href="#require.resolve">require.resolve()</a></li><li><a href="#require.paths">require.paths</a></li><li><a href="#__filename">__filename</a></li><li><a href="#__dirname">__dirname</a></li><li><a href="#module">module</a></li></ul></li><li><a href="#timers_">Timers 定时器</a><ul><li><a href="#setTimeout">setTimeout(callback, delay, [arg], [...])</a></li><li><a href="#clearTimeout">clearTimeout(timeoutId)</a></li><li><a href="#setInterval">setInterval(callback, delay, [arg], [...])</a></li><li><a href="#clearInterval">clearInterval(intervalId)</a></li></ul></li><li><a href="#modules_">Modules 模块</a><ul><li><a href="#core_Modules_">Core Modules 核心模块</a></li><li><a href="#file_Modules_">File Modules 文件模块</a></li><li><a href="#loading_from_node_modules_Folders_node_modules_">Loading from `node_modules` Folders 从 `node_modules` 目录中加载</a><ul><li><a href="#optimizations_to_the_node_modules_Lookup_Process_node_modules_">Optimizations to the `node_modules` Lookup Process 优化 `node_modules` 的查找过程</a></li></ul></li><li><a href="#folders_as_Modules_">Folders as Modules 目录作为模块</a></li><li><a href="#caching_">Caching 缓存</a></li><li><a href="#all_Together..._...">All Together... 总结一下...</a></li><li><a href="#loading_from_the_require.paths_Folders_require.paths_">Loading from the `require.paths` Folders 从`require.paths`目录中加载</a><ul><li><a href="#note_Please_Avoid_Modifying_require.paths_requires.paths_">Note:** Please Avoid Modifying `require.paths` **注意：** 请不要修改`requires.paths`</a><ul><li><a href="#setting_require.paths_to_some_other_value_does_nothing._require.paths_">Setting `require.paths` to some other value does nothing. 将`require.paths`设为其他值不会产生任何作用</a></li><li><a href="#putting_relative_paths_in_require.paths_is..._weird._require.paths_">Putting relative paths in `require.paths` is... weird.  不建议在`require.paths`中发入相对路径</a></li><li><a href="#zero_Isolation_">Zero Isolation 零隔离</a></li></ul></li></ul></li></ul></li><li><a href="#addenda_Package_Manager_Tips_">Addenda: Package Manager Tips 附录：包管理技巧</a></li><li><a href="#addons_">Addons  扩展插件</a></li><li><a href="#process_">process 进程</a><ul><li><a href="#event_exit_exit_">Event: 'exit' 事件：'exit'</a></li><li><a href="#event_uncaughtException_uncaughtException_">Event: 'uncaughtException' 事件：'uncaughtException'</a></li><li><a href="#signal_Events_">Signal Events 信号事件</a></li><li><a href="#process.stdout">process.stdout</a></li><li><a href="#process.stderr">process.stderr</a></li><li><a href="#process.stdin">process.stdin</a></li><li><a href="#process.argv">process.argv</a></li><li><a href="#process.execPath">process.execPath</a></li><li><a href="#process.chdir">process.chdir(directory)</a></li><li><a href="#process.cwd">process.cwd()</a></li><li><a href="#process.env">process.env</a></li><li><a href="#process.exit">process.exit(code=0)</a></li><li><a href="#process.getgid">process.getgid()</a></li><li><a href="#process.setgid">process.setgid(id)</a></li><li><a href="#process.getuid">process.getuid()</a></li><li><a href="#process.setuid">process.setuid(id)</a></li><li><a href="#process.version">process.version</a></li><li><a href="#process.installPrefix">process.installPrefix</a></li><li><a href="#process.kill">process.kill(pid, signal='SIGTERM')</a></li><li><a href="#process.pid">process.pid</a></li><li><a href="#process.title">process.title</a></li><li><a href="#process.platform">process.platform</a></li><li><a href="#process.memoryUsage">process.memoryUsage()</a></li><li><a href="#process.nextTick">process.nextTick(callback)</a></li><li><a href="#process.umask">process.umask([mask])</a></li></ul></li><li><a href="#util_">util 工具模块</a><ul><li><a href="#util.debug">util.debug(string)</a></li><li><a href="#util.log">util.log(string)</a></li><li><a href="#util.inspect">util.inspect(object, showHidden=false, depth=2)</a></li><li><a href="#util.pump">util.pump(readableStream, writableStream, [callback])</a></li><li><a href="#util.inherits">util.inherits(constructor, superConstructor)</a></li></ul></li><li><a href="#events_">Events 事件模块</a><ul><li><a href="#events.EventEmitter">events.EventEmitter</a><ul><li><a href="#emitter.addListener">emitter.addListener(event, listener)</a></li><li><a href="#emitter.on">emitter.on(event, listener)</a></li><li><a href="#emitter.once">emitter.once(event, listener)</a></li><li><a href="#emitter.removeListener">emitter.removeListener(event, listener)</a></li><li><a href="#emitter.removeAllListeners">emitter.removeAllListeners(event)</a></li><li><a href="#emitter.setMaxListeners">emitter.setMaxListeners(n)</a></li><li><a href="#emitter.listeners">emitter.listeners(event)</a></li><li><a href="#emitter.emit">emitter.emit(event, [arg1], [arg2], [...])</a></li><li><a href="#event_newListener_newListener_">Event: 'newListener' 事件：'newListener'</a></li></ul></li></ul></li><li><a href="#buffers_">Buffers  缓冲器</a><ul><li><a href="#new_Buffer">new Buffer(size)</a></li><li><a href="#new_Buffer">new Buffer(array)</a></li><li><a href="#new_Buffer">new Buffer(str, encoding='utf8')</a></li><li><a href="#buffer.write">buffer.write(string, offset=0, encoding='utf8')</a></li><li><a href="#buffer.toString">buffer.toString(encoding, start=0, end=buffer.length)</a></li><li><a href="#buffer_index_">buffer[index]</a></li><li><a href="#buffer.isBuffer">Buffer.isBuffer(obj)</a></li><li><a href="#buffer.byteLength">Buffer.byteLength(string, encoding='utf8')</a></li><li><a href="#buffer.length">buffer.length</a></li><li><a href="#buffer.copy">buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</a></li><li><a href="#buffer.slice">buffer.slice(start, end=buffer.length)</a></li></ul></li><li><a href="#streams_">Streams 流</a></li><li><a href="#readable_Stream_">Readable Stream 可读流</a><ul><li><a href="#event_data_data_">Event: 'data' 事件：'data'</a></li><li><a href="#event_end_end_">Event: 'end' 事件：'end'</a></li><li><a href="#event_error_error_">Event: 'error' 事件：'error'</a></li><li><a href="#event_close_close_">Event: 'close' 事件：'close'</a></li><li><a href="#event_fd_fd_">Event: 'fd' 事件：'fd'</a></li><li><a href="#stream.readable">stream.readable</a></li><li><a href="#stream.setEncoding">stream.setEncoding(encoding)</a></li><li><a href="#stream.pause">stream.pause()</a></li><li><a href="#stream.resume">stream.resume()</a></li><li><a href="#stream.destroy">stream.destroy()</a></li><li><a href="#stream.destroySoon">stream.destroySoon()</a></li><li><a href="#stream.pipe">stream.pipe(destination, [options])</a></li></ul></li><li><a href="#writable_Stream_">Writable Stream 可写流</a><ul><li><a href="#event_drain_drain_">Event: 'drain' 事件：'drain'</a></li><li><a href="#event_error_error_">Event: 'error' 事件：'error'</a></li><li><a href="#event_close_close_">Event: 'close' 事件：'close'</a></li><li><a href="#event_pipe_pipe_">Event: 'pipe' 事件：'pipe'</a></li><li><a href="#stream.writable">stream.writable</a></li><li><a href="#stream.write">stream.write(string, encoding='utf8', [fd])</a></li><li><a href="#stream.write">stream.write(buffer)</a></li><li><a href="#stream.end">stream.end()</a></li><li><a href="#stream.end">stream.end(string, encoding)</a></li><li><a href="#stream.end">stream.end(buffer)</a></li><li><a href="#stream.destroy">stream.destroy()</a></li></ul></li><li><a href="#crypto_">Crypto 加密模块</a><ul><li><a href="#crypto.createCredentials">crypto.createCredentials(details)</a></li><li><a href="#crypto.createHash">crypto.createHash(algorithm)</a></li><li><a href="#hash.update">hash.update(data)</a></li><li><a href="#hash.digest">hash.digest(encoding='binary')</a></li><li><a href="#crypto.createHmac">crypto.createHmac(algorithm, key)</a></li><li><a href="#hmac.update">hmac.update(data)</a></li><li><a href="#hmac.digest">hmac.digest(encoding='binary')</a></li><li><a href="#crypto.createCipher">crypto.createCipher(algorithm, key)</a></li><li><a href="#cipher.update">cipher.update(data, input_encoding='binary', output_encoding='binary')</a></li><li><a href="#cipher.final">cipher.final(output_encoding='binary')</a></li><li><a href="#crypto.createDecipher">crypto.createDecipher(algorithm, key)</a></li><li><a href="#decipher.update">decipher.update(data, input_encoding='binary', output_encoding='binary')</a></li><li><a href="#decipher.final">decipher.final(output_encoding='binary')</a></li><li><a href="#crypto.createSign">crypto.createSign(algorithm)</a></li><li><a href="#signer.update">signer.update(data)</a></li><li><a href="#signer.sign">signer.sign(private_key, output_format='binary')</a></li><li><a href="#crypto.createVerify">crypto.createVerify(algorithm)</a></li><li><a href="#verifier.update">verifier.update(data)</a></li><li><a href="#verifier.verify">verifier.verify(cert, signature, signature_format='binary')</a></li></ul></li><li><a href="#tLS_TLS_">TLS (SSL) TLS (SSL)模块</a><ul><li><a href="#s_tls.connect">s = tls.connect(port, [host], [options], callback)</a></li><li><a href="#tls.Server">tls.Server</a><ul><li><a href="#tls.createServer">tls.createServer(options, secureConnectionListener)</a></li><li><a href="#event_secureConnection_secureConnection_">Event: 'secureConnection' 事件：'secureConnection'</a></li><li><a href="#server.listen">server.listen(port, [host], [callback])</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li></ul></li></ul></li><li><a href="#file_System_">File System 文件系统模块</a><ul><li><a href="#fs.rename">fs.rename(path1, path2, [callback])</a></li><li><a href="#fs.renameSync">fs.renameSync(path1, path2)</a></li><li><a href="#fs.truncate">fs.truncate(fd, len, [callback])</a></li><li><a href="#fs.truncateSync">fs.truncateSync(fd, len)</a></li><li><a href="#fs.chmod">fs.chmod(path, mode, [callback])</a></li><li><a href="#fs.chmodSync">fs.chmodSync(path, mode)</a></li><li><a href="#fs.stat">fs.stat(path, [callback])</a></li><li><a href="#fs.lstat">fs.lstat(path, [callback])</a></li><li><a href="#fs.fstat">fs.fstat(fd, [callback])</a></li><li><a href="#fs.statSync">fs.statSync(path)</a></li><li><a href="#fs.lstatSync">fs.lstatSync(path)</a></li><li><a href="#fs.fstatSync">fs.fstatSync(fd)</a></li><li><a href="#fs.link">fs.link(srcpath, dstpath, [callback])</a></li><li><a href="#fs.linkSync">fs.linkSync(srcpath, dstpath)</a></li><li><a href="#fs.symlink">fs.symlink(linkdata, path, [callback])</a></li><li><a href="#fs.symlinkSync">fs.symlinkSync(linkdata, path)</a></li><li><a href="#fs.readlink">fs.readlink(path, [callback])</a></li><li><a href="#fs.readlinkSync">fs.readlinkSync(path)</a></li><li><a href="#fs.realpath">fs.realpath(path, [callback])</a></li><li><a href="#fs.realpathSync">fs.realpathSync(path)</a></li><li><a href="#fs.unlink">fs.unlink(path, [callback])</a></li><li><a href="#fs.unlinkSync">fs.unlinkSync(path)</a></li><li><a href="#fs.rmdir">fs.rmdir(path, [callback])</a></li><li><a href="#fs.rmdirSync">fs.rmdirSync(path)</a></li><li><a href="#fs.mkdir">fs.mkdir(path, mode, [callback])</a></li><li><a href="#fs.mkdirSync">fs.mkdirSync(path, mode)</a></li><li><a href="#fs.readdir">fs.readdir(path, [callback])</a></li><li><a href="#fs.readdirSync">fs.readdirSync(path)</a></li><li><a href="#fs.close">fs.close(fd, [callback])</a></li><li><a href="#fs.closeSync">fs.closeSync(fd)</a></li><li><a href="#fs.open">fs.open(path, flags, mode=0666, [callback])</a></li><li><a href="#fs.openSync">fs.openSync(path, flags, mode=0666)</a></li><li><a href="#fs.utimes">fs.utimes(path, atime, mtime, callback)</a></li><li><a href="#fs.utimesSync">fs.utimesSync(path, atime, mtime)</a></li><li><a href="#fs.futimes">fs.futimes(path, atime, mtime, callback)</a></li><li><a href="#fs.futimesSync">fs.futimesSync(path, atime, mtime)</a></li><li><a href="#fs.write">fs.write(fd, buffer, offset, length, position, [callback])</a></li><li><a href="#fs.writeSync">fs.writeSync(fd, buffer, offset, length, position)</a></li><li><a href="#fs.writeSync">fs.writeSync(fd, str, position, encoding='utf8')</a></li><li><a href="#fs.read">fs.read(fd, buffer, offset, length, position, [callback])</a></li><li><a href="#fs.readSync">fs.readSync(fd, buffer, offset, length, position)</a></li><li><a href="#fs.readSync">fs.readSync(fd, length, position, encoding)</a></li><li><a href="#fs.readFile">fs.readFile(filename, [encoding], [callback])</a></li><li><a href="#fs.readFileSync">fs.readFileSync(filename, [encoding])</a></li><li><a href="#fs.writeFile">fs.writeFile(filename, data, encoding='utf8', [callback])</a></li><li><a href="#fs.writeFileSync">fs.writeFileSync(filename, data, encoding='utf8')</a></li><li><a href="#fs.watchFile">fs.watchFile(filename, [options], listener)</a></li><li><a href="#fs.unwatchFile">fs.unwatchFile(filename)</a></li></ul></li><li><a href="#fs.Stats">fs.Stats</a></li><li><a href="#fs.ReadStream">fs.ReadStream</a><ul><li><a href="#fs.createReadStream">fs.createReadStream(path, [options])</a></li></ul></li><li><a href="#fs.WriteStream">fs.WriteStream</a><ul><li><a href="#event_open_open_">Event: 'open' 事件：'open'</a></li><li><a href="#fs.createWriteStream">fs.createWriteStream(path, [options])</a></li></ul></li><li><a href="#path_">Path 路径模块</a><ul><li><a href="#path.normalize">path.normalize(p)</a></li><li><a href="#path.join">path.join([path1], [path2], [...])</a></li><li><a href="#path.resolve">path.resolve([from ...], to)</a></li><li><a href="#path.dirname">path.dirname(p)</a></li><li><a href="#path.basename">path.basename(p, [ext])</a></li><li><a href="#path.extname">path.extname(p)</a></li><li><a href="#path.exists">path.exists(p, [callback])</a></li><li><a href="#path.existsSync">path.existsSync(p)</a></li></ul></li><li><a href="#net_">net 网络模块</a><ul><li><a href="#net.createServer">net.createServer([options], [connectionListener])</a></li><li><a href="#net.createConnection">net.createConnection(arguments...)</a></li><li><a href="#net.Server">net.Server</a><ul><li><a href="#server.listen">server.listen(port, [host], [callback])</a></li><li><a href="#server.listen">server.listen(path, [callback])</a></li><li><a href="#server.listenFD">server.listenFD(fd)</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.address">server.address()</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li><li><a href="#event_connection_connection_">Event: 'connection' 事件：'connection'</a></li><li><a href="#event_close_">Event: 'close'</a></li></ul></li><li><a href="#net.Socket">net.Socket</a><ul><li><a href="#new_net.Socket">new net.Socket([options])</a></li><li><a href="#socket.connect">socket.connect(port, [host], [callback])</a></li><li><a href="#socket.connect">socket.connect(path, [callback])</a></li><li><a href="#socket.bufferSize">socket.bufferSize</a></li><li><a href="#socket.setEncoding">socket.setEncoding(encoding=null)</a></li><li><a href="#socket.setSecure">socket.setSecure()</a></li><li><a href="#socket.write">socket.write(data, [encoding], [callback])</a></li><li><a href="#socket.write">socket.write(data, [encoding], [fileDescriptor], [callback])</a></li><li><a href="#socket.end">socket.end([data], [encoding])</a></li><li><a href="#socket.destroy">socket.destroy()</a></li><li><a href="#socket.pause">socket.pause()</a></li><li><a href="#socket.resume">socket.resume()</a></li><li><a href="#socket.setTimeout">socket.setTimeout(timeout, [callback])</a></li><li><a href="#socket.setNoDelay">socket.setNoDelay(noDelay=true)</a></li><li><a href="#socket.setKeepAlive">socket.setKeepAlive(enable=false, [initialDelay])</a></li><li><a href="#socket.remoteAddress">socket.remoteAddress</a></li><li><a href="#event_connect_connect_">Event: 'connect' 事件：'connect'</a></li><li><a href="#event_data_data_">Event: 'data' 事件：'data'</a></li><li><a href="#event_end_end_">Event: 'end' 事件：'end'</a></li><li><a href="#event_timeout_timeout_">Event: 'timeout' 事件：'timeout'</a></li><li><a href="#event_drain_drain_">Event: 'drain' 事件：'drain'</a></li><li><a href="#event_error_error_">Event: 'error' 事件：'error'</a></li><li><a href="#event_close_close_">Event: 'close' 事件：'close'</a></li></ul></li><li><a href="#net.isIP">net.isIP</a><ul><li><a href="#net.isIP">net.isIP(input)</a></li><li><a href="#net.isIPv4">net.isIPv4(input)</a></li><li><a href="#net.isIPv6">net.isIPv6(input)</a></li></ul></li></ul></li><li><a href="#dNS_DNS_">DNS DNS模块</a><ul><li><a href="#dns.lookup">dns.lookup(domain, family=null, callback)</a></li><li><a href="#dns.resolve">dns.resolve(domain, rrtype='A', callback)</a></li><li><a href="#dns.resolve4">dns.resolve4(domain, callback)</a></li><li><a href="#dns.resolve6">dns.resolve6(domain, callback)</a></li><li><a href="#dns.resolveMx">dns.resolveMx(domain, callback)</a></li><li><a href="#dns.resolveTxt">dns.resolveTxt(domain, callback)</a></li><li><a href="#dns.resolveSrv">dns.resolveSrv(domain, callback)</a></li><li><a href="#dns.reverse">dns.reverse(ip, callback)</a></li></ul></li><li><a href="#uDP_Datagram_Sockets_">UDP / Datagram Sockets 数据报套接字模块</a><ul><li><a href="#event_message_message_">Event: 'message' 事件：'message'</a></li><li><a href="#event_listening_listening_">Event: 'listening' 事件：'listening'</a></li><li><a href="#event_close_close_">Event: 'close' 事件：'close'</a></li><li><a href="#dgram.createSocket">dgram.createSocket(type, [callback])</a></li><li><a href="#dgram.send">dgram.send(buf, offset, length, path, [callback])</a></li><li><a href="#dgram.send">dgram.send(buf, offset, length, port, address, [callback])</a></li><li><a href="#dgram.bind">dgram.bind(path)</a></li><li><a href="#dgram.bind">dgram.bind(port, [address])</a></li><li><a href="#dgram.close">dgram.close()</a></li><li><a href="#dgram.address">dgram.address()</a></li><li><a href="#dgram.setBroadcast">dgram.setBroadcast(flag)</a></li><li><a href="#dgram.setTTL">dgram.setTTL(ttl)</a></li><li><a href="#dgram.setMulticastTTL">dgram.setMulticastTTL(ttl)</a></li><li><a href="#dgram.setMulticastLoopback">dgram.setMulticastLoopback(flag)</a></li><li><a href="#dgram.addMembership">dgram.addMembership(multicastAddress, [multicastInterface])</a></li><li><a href="#dgram.dropMembership">dgram.dropMembership(multicastAddress, [multicastInterface])</a></li></ul></li><li><a href="#hTTP_HTTP_">HTTP HTTP模块</a></li><li><a href="#http.Server">http.Server</a><ul><li><a href="#event_request_request_">Event: 'request' 事件：'request'</a></li><li><a href="#event_connection_connection_">Event: 'connection' 事件：'connection'</a></li><li><a href="#event_close_close_">Event: 'close' 事件：'close'</a></li><li><a href="#event_request_request_">Event: 'request' 事件：'request'</a></li><li><a href="#event_checkContinue_checkContinue_">Event: 'checkContinue' 事件：'checkContinue'</a></li><li><a href="#event_upgrade_upgrade_">Event: 'upgrade' 事件：'upgrade'</a></li><li><a href="#event_clientError_clientError_">Event: 'clientError' 事件：'clientError'</a></li><li><a href="#http.createServer">http.createServer(requestListener)</a></li><li><a href="#server.listen">server.listen(port, [hostname], [callback])</a></li><li><a href="#server.listen">server.listen(path, [callback])</a></li><li><a href="#server.close">server.close()</a></li></ul></li><li><a href="#http.ServerRequest">http.ServerRequest</a><ul><li><a href="#event_data_data_">Event: 'data' 事件：'data'</a></li><li><a href="#event_end_end_">Event: 'end' 事件：'end'</a></li><li><a href="#request.method">request.method</a></li><li><a href="#request.url">request.url</a></li><li><a href="#request.headers">request.headers</a></li><li><a href="#request.trailers">request.trailers</a></li><li><a href="#request.httpVersion">request.httpVersion</a></li><li><a href="#request.setEncoding">request.setEncoding(encoding=null)</a></li><li><a href="#request.pause">request.pause()</a></li><li><a href="#request.resume">request.resume()</a></li><li><a href="#request.connection">request.connection</a></li></ul></li><li><a href="#http.ServerResponse">http.ServerResponse</a><ul><li><a href="#response.writeContinue">response.writeContinue()</a></li><li><a href="#response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li><li><a href="#response.statusCode">response.statusCode</a></li><li><a href="#response.setHeader">response.setHeader(name, value)</a></li><li><a href="#response.getHeader">response.getHeader(name)</a></li><li><a href="#response.removeHeader">response.removeHeader(name)</a></li><li><a href="#response.write">response.write(chunk, encoding='utf8')</a></li><li><a href="#response.addTrailers">response.addTrailers(headers)</a></li><li><a href="#response.end">response.end([data], [encoding])</a></li></ul></li><li><a href="#http.request">http.request(options, callback)</a></li><li><a href="#http.get">http.get(options, callback)</a></li><li><a href="#http.Agent">http.Agent</a></li><li><a href="#http.getAgent">http.getAgent(host, port)</a><ul><li><a href="#event_upgrade_upgrade_">Event: 'upgrade' 事件：'upgrade'</a></li><li><a href="#event_continue_continue_">Event: 'continue' 事件：'continue'</a></li><li><a href="#agent.maxSockets">agent.maxSockets</a></li><li><a href="#agent.sockets">agent.sockets</a></li><li><a href="#agent.queue">agent.queue</a></li></ul></li><li><a href="#http.ClientRequest">http.ClientRequest</a><ul><li><a href="#event_response_response_">Event 'response' 事件：'response'</a></li><li><a href="#request.write">request.write(chunk, encoding='utf8')</a></li><li><a href="#request.end">request.end([data], [encoding])</a></li><li><a href="#request.abort">request.abort()</a></li></ul></li><li><a href="#http.ClientResponse">http.ClientResponse</a><ul><li><a href="#event_data_data_">Event: 'data' 事件：'data'</a></li><li><a href="#event_end_end_">Event: 'end' 事件：'end'</a></li><li><a href="#response.statusCode">response.statusCode</a></li><li><a href="#response.httpVersion">response.httpVersion</a></li><li><a href="#response.headers">response.headers</a></li><li><a href="#response.trailers">response.trailers</a></li><li><a href="#response.setEncoding">response.setEncoding(encoding=null)</a></li><li><a href="#response.pause">response.pause()</a></li><li><a href="#response.resume">response.resume()</a></li></ul></li><li><a href="#https.Server">https.Server</a></li><li><a href="#https.createServer">https.createServer</a></li><li><a href="#https.request">https.request(options, callback)</a></li><li><a href="#https.get">https.get(options, callback)</a></li><li><a href="#uRL_URL_">URL URL模块</a><ul><li><a href="#url.parse">url.parse(urlStr, parseQueryString=false)</a></li><li><a href="#url.format">url.format(urlObj)</a></li><li><a href="#url.resolve">url.resolve(from, to)</a></li></ul></li><li><a href="#query_String_">Query String 查询字符串模块</a><ul><li><a href="#querystring.stringify">querystring.stringify(obj, sep='&', eq='=')</a></li><li><a href="#querystring.parse">querystring.parse(str, sep='&', eq='=')</a></li><li><a href="#querystring.escape">querystring.escape</a></li><li><a href="#querystring.unescape">querystring.unescape</a></li></ul></li><li><a href="#rEPL_">REPL 交互式解释器</a><ul><li><a href="#repl.start">repl.start(prompt='> ', stream=process.stdin)</a></li><li><a href="#rEPL_Features_REPL_">REPL Features REPL特性</a></li></ul></li><li><a href="#child_Processes_">Child Processes  子进程</a><ul><li><a href="#event_exit_exit_">Event:  'exit' 事件：'exit'</a></li><li><a href="#child.stdin">child.stdin</a></li><li><a href="#child.stdout">child.stdout</a></li><li><a href="#child.stderr">child.stderr</a></li><li><a href="#child.pid">child.pid</a></li><li><a href="#child_process.spawn">child_process.spawn(command, args=[], [options])</a></li><li><a href="#child_process.exec">child_process.exec(command, [options], callback)</a></li><li><a href="#child.kill">child.kill(signal='SIGTERM')</a></li></ul></li><li><a href="#assert_">Assert  断言模块</a><ul><li><a href="#assert.fail">assert.fail(actual, expected, message, operator)</a></li><li><a href="#assert.ok">assert.ok(value, [message])</a></li><li><a href="#assert.equal">assert.equal(actual, expected, [message])</a></li><li><a href="#assert.notEqual">assert.notEqual(actual, expected, [message])</a></li><li><a href="#assert.deepEqual">assert.deepEqual(actual, expected, [message])</a></li><li><a href="#assert.notDeepEqual">assert.notDeepEqual(actual, expected, [message])</a></li><li><a href="#assert.strictEqual">assert.strictEqual(actual, expected, [message])</a></li><li><a href="#assert.notStrictEqual">assert.notStrictEqual(actual, expected, [message])</a></li><li><a href="#assert.throws">assert.throws(block, [error], [message])</a></li><li><a href="#assert.doesNotThrow">assert.doesNotThrow(block, [error], [message])</a></li><li><a href="#assert.ifError">assert.ifError(value)</a></li></ul></li><li><a href="#tTY_">TTY 终端模块</a><ul><li><a href="#tty.open">tty.open(path, args=[])</a></li><li><a href="#tty.isatty">tty.isatty(fd)</a></li><li><a href="#tty.setRawMode">tty.setRawMode(mode)</a></li><li><a href="#tty.setWindowSize">tty.setWindowSize(fd, row, col)</a></li><li><a href="#tty.getWindowSize">tty.getWindowSize(fd)</a></li></ul></li><li><a href="#os_Module_">os Module 操作系统模块</a><ul><li><a href="#os.hostname">os.hostname()</a></li><li><a href="#os.type">os.type()</a></li><li><a href="#os.release">os.release()</a></li><li><a href="#os.uptime">os.uptime()</a></li><li><a href="#os.loadavg">os.loadavg()</a></li><li><a href="#os.totalmem">os.totalmem()</a></li><li><a href="#os.freemem">os.freemem()</a></li><li><a href="#os.cpus">os.cpus()</a></li></ul></li><li><a href="#debugger_">Debugger 调试器</a><ul><li><a href="#advanced_Usage_">Advanced Usage 高级用法</a></li></ul></li></ul></li><li><a href="#appendixes_">Appendixes 附录</a><ul><li><a href="#appendix_1_Third_Party_Modules_1_">Appendix 1 - Third Party Modules  附录 1 - 第三方模块</a></li></ul><hr /></div>
<h2 id="synopsis_">Synopsis 概要</h2>

<p>An example of a <a href="http.html">web server</a> written with Node which responds with 'Hello
World':</p>

<p>下边是一个用Node编写的对所有请求简单返回'Hello World‘的<a href="http.html">web服务器</a>例子：</p>

<pre><code>var http = require('http');

http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/plain'});
  response.end('Hello World\n');
}).listen(8124);

console.log('Server running at http://127.0.0.1:8124/');</code></pre>

<p>To run the server, put the code into a file called <code>example.js</code> and execute
it with the node program</p>

<p>要运行这个服务器程序，只要将上述代码保存为文件<code>example.js</code>并用node程序执行此文件：</p>

<pre><code>&gt; node example.js
Server running at http://127.0.0.1:8124/</code></pre>

<p>All of the examples in the documentation can be run similarly.</p>

<p>此文档中所有例子均可用同样的方法运行。
## Global Objects 全局对象</p>

<p>These object are available in the global scope and can be accessed from anywhere.</p>

<p>这些对象在全局范围内均可用，你可以在任何位置访问这些对象。</p>

<h3 id="global">global</h3>

<p>The global namespace object.</p>

<p>全局命名空间对象</p>

<p>In browsers, the top-level scope is the global scope. That means that in
browsers if you're in the global scope <code>var something</code> will define a global
variable. In Node this is different. The top-level scope is not the global
scope; <code>var something</code> inside a Node module will be local to that module.</p>

<p>在浏览器中，顶级作用域为全局作用域，在全局作用域下通过<code>var something</code>即定义了一个全局变量。但是在Node中并不如此，顶级作用域并非是全局作用域，在Node模块中通过<code>var something</code>定义的变量仅作用于该模块。</p>

<h3 id="process">process</h3>

<p>The process object. See the 'process object' section.</p>

<p>进程对象，参见'process object'章节。</p>

<h3 id="require">require()</h3>

<p>To require modules. See the 'Modules' section.</p>

<p>加载模块，参见'Modules'章节。</p>

<h3 id="require.resolve">require.resolve()</h3>

<p>Use the internal <code>require()</code> machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.</p>

<p>使用内部函数<code>require()</code>的机制查找一个模块的位置，而不用加载模块，只是返回解析后的文件名。</p>

<h3 id="require.paths">require.paths</h3>

<p>An array of search paths for <code>require()</code>.  This array can be modified to add
custom paths.</p>

<p><code>require()</code>的搜索路径数组，你可以修改该数组添加自定义的搜索路径。</p>

<p>Example: add a new path to the beginning of the search list</p>

<p>例如：将一个新的搜索路径插入到搜索列表的头部。</p>

<pre><code>require.paths.unshift('/usr/local/node');</code></pre>

<h3 id="__filename">__filename</h3>

<p>The filename of the script being executed.  This is the absolute path, and not necessarily
the same filename passed in as a command line argument.</p>

<p>当前正在执行的脚本的文件名。这是一个绝对路径，可能会和命令行参数中传入的文件名不同。</p>

<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>

<p>例如：在目录<code>/Users/mjr</code>下运行<code>node example.js</code></p>

<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>

<h3 id="__dirname">__dirname</h3>

<p>The dirname of the script being executed.</p>

<p>当前正在执行脚本所在的目录名。</p>

<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>

<p>例如：在目录<code>/Users/mjr</code>下运行<code>node example.js</code></p>

<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>

<h3 id="module">module</h3>

<p>A reference to the current module. In particular
<code>module.exports</code> is the same as the <code>exports</code> object. See <code>src/node.js</code>
for more information.</p>

<p>指向当前模块的引用。特别的，当你通过<code>module.exports</code>和<code>exports</code>两种方式访问的将是同一个对象，参见<code>src/node.js</code>。</p>

<h2 id="timers_">Timers 定时器</h2>

<h3 id="setTimeout">setTimeout(callback, delay, [arg], [...])</h3>

<p>To schedule execution of <code>callback</code> after <code>delay</code> milliseconds. Returns a
<code>timeoutId</code> for possible use with <code>clearTimeout()</code>. Optionally, you can
also pass arguments to the callback.</p>

<p>设定一个<code>delay</code>毫秒后执行<code>callback</code>回调函数的计划。返回值<code>timeoutId</code>可被用于<code>clearTimeout()</code>。可以设定要传递给回调函数的参数。</p>

<h3 id="clearTimeout">clearTimeout(timeoutId)</h3>

<p>Prevents a timeout from triggering.</p>

<p>清除定时器，阻止指定的timeout（超时）定时器被触发。</p>

<h3 id="setInterval">setInterval(callback, delay, [arg], [...])</h3>

<p>To schedule the repeated execution of <code>callback</code> every <code>delay</code> milliseconds.
Returns a <code>intervalId</code> for possible use with <code>clearInterval()</code>. Optionally,
you can also pass arguments to the callback.</p>

<p>设定一个每<code>delay</code>毫秒重复执行<code>callback</code>回调函数的计划。返回值<code>intervalId</code>可被用于<code>clearInterval()</code>。可以设定要传递给回调函数的参数。</p>

<h3 id="clearInterval">clearInterval(intervalId)</h3>

<p>Stops a interval from triggering.</p>

<p>清除定时器，阻止指定的interval（间隔）定时器被触发。
## Modules 模块</p>

<p>Node uses the CommonJS module system.
Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <code>foo.js</code> loads the module
<code>circle.js</code> in the same directory.</p>

<p>Node使用CommonJS模块系统。Node有一个简单的模块装载系统，在Node中，文件和模块是一一对应的。下面的例子展示了<code>foo.js</code>文件如何在相同的目录中加载<code>circle.js</code>模块。</p>

<p>The contents of <code>foo.js</code>:</p>

<p><code>foo.js</code>的内容为：</p>

<pre><code>var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));</code></pre>

<p>The contents of <code>circle.js</code>:</p>

<p><code>circle.js</code>的内容为：</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>

<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and
<code>circumference()</code>.  To export an object, add to the special <code>exports</code>
object.</p>

<p><code>circle.js</code>模块输出了<code>area()</code>和<code>circumference()</code>两个函数，为了以对象的形式输出，需将要输出的函数加入到一个特殊的<code>exports</code>对像中。</p>

<p>Variables
local to the module will be private. In this example the variable <code>PI</code> is
private to <code>circle.js</code>.</p>

<p>模块的本地变量是私有的。在上面的例子中，变量<code>PI</code>就是<code>circle.js</code>私有的。</p>

<h3 id="core_Modules_">Core Modules 核心模块</h3>

<p>Node has several modules compiled into the binary.  These modules are
described in greater detail elsewhere in this documentation.</p>

<p>Node有一些编译成二进制的模块。这些模块在这篇文档的其他地方有详细描述。</p>

<p>The core modules are defined in node's source in the <code>lib/</code> folder.</p>

<p>核心模块在node源代码中的lib文件夹下。</p>

<p>Core modules are always preferentially loaded if their identifier is
passed to <code>require()</code>.  For instance, <code>require('http')</code> will always
return the built in HTTP module, even if there is a file by that name.</p>

<p>核心模块总是被优先加载，如果它们的标识符被<code>require()</code>调用。例如，<code>require('http')</code>将总是返回内建的HTTP模块，即便又一个同名文件存在。</p>

<h3 id="file_Modules_">File Modules 文件模块</h3>

<p>If the exact filename is not found, then node will attempt to load the
required filename with the added extension of <code>.js</code>, and then <code>.node</code>.
<code>.js</code> files are interpreted as JavaScript text files, and <code>.node</code> files
are interpreted as compiled addon modules loaded with <code>dlopen</code>.</p>

<p>如果没有找到确切的文件名，node将尝试以追加扩展名<code>.js</code>后的文件名读取文件，如果还是没有找到则尝试追加扩展名<code>.node</code>。<code>.js</code>文件被解释为JavaScript格式的纯文本文件，<code>.node</code>文件被解释为编译后的addon（插件）模块，并使用<code>dlopen</code>来加载。</p>

<p>A module prefixed with <code>'/'</code> is an absolute path to the file.  For
example, <code>require('/home/marco/foo.js')</code> will load the file at
<code>/home/marco/foo.js</code>.</p>

<p>以<code>'/'</code>为前缀的模块是一个指向文件的绝对路径，例如<code>require('/home/marco/foo.js')</code>将加载文件<code>/home/marco/foo.js</code>。</p>

<p>A module prefixed with <code>'./'</code> is relative to the file calling <code>require()</code>.
That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for
<code>require('./circle')</code> to find it.</p>

<p>以<code>'./'</code>为前缀的模块是指向文件的相对路径，相对于调用<code>require()</code>的文件。也就是说为了使<code>require('./circle')</code> 能找到正确的文件，<code>circle.js</code>必须位于与<code>foo.js</code> 相同的路径之下。</p>

<p>Without a leading '/' or './' to indicate a file, the module is either a
"core module" or is loaded from a <code>node_modules</code> folder.</p>

<p>如果标明一个文件时没有 '/' 或 './'前缀，该模块或是"核心模块"，或者位于 <code>node_modules</code>目录中。</p>

<h3 id="loading_from_node_modules_Folders_node_modules_">Loading from `node_modules` Folders 从 `node_modules` 目录中加载</h3>

<p>If the module identifier passed to <code>require()</code> is not a native module,
and does not begin with <code>'/'</code>, <code>'../'</code>, or <code>'./'</code>, then node starts at the
parent directory of the current module, and adds <code>/node_modules</code>, and
attempts to load the module from that location.</p>

<p>如果传递到 <code>require()</code>的模块标识符不是一个核心模块，并且不是以<code>'/'</code>，<code>'../'</code>或<code>'./'</code>开头，node将从当前模块的父目录开始，在其<code>/node_modules</code>子目录中加载该模块。</p>

<p>If it is not found there, then it moves to the parent directory, and so
on, until either the module is found, or the root of the tree is
reached.</p>

<p>如果在那里没有找到，就转移到上一级目录，依此类推，直到找到该模块或到达目录树的根结点。</p>

<p>For example, if the file at <code>'/home/ry/projects/foo.js'</code> called
<code>require('bar.js')</code>, then node would look in the following locations, in
this order:</p>

<p>例如，如果在文件 <code>'/home/ry/projects/foo.js'</code>中调用 `require('bar.js')，node将会依次查找以下位置：</p>

<ul><li><code>/home/ry/projects/node_modules/bar.js</code></li><li><code>/home/ry/node_modules/bar.js</code></li><li><code>/home/node_modules/bar.js</code></li><li><code>/node_modules/bar.js</code></li></ul>

<p>This allows programs to localize their dependencies, so that they do not
clash.</p>

<p>这允许程序本地化他们的依赖关系，避免发生冲突。</p>

<h4 id="optimizations_to_the_node_modules_Lookup_Process_node_modules_">Optimizations to the `node_modules` Lookup Process 优化 `node_modules` 的查找过程</h4>

<p>When there are many levels of nested dependencies, it is possible for
these file trees to get fairly long.  The following optimizations are thus
made to the process.</p>

<p>如果有很多级的嵌套信赖，文件树会变得相当的长，下面是对这一过程的一些优化。</p>

<p>First, <code>/node_modules</code> is never appended to a folder already ending in
<code>/node_modules</code>.</p>

<p>首先， <code>/node_modules</code>不要添加到以 <code>/node_modules</code>结尾的目录上。</p>

<p>Second, if the file calling <code>require()</code> is already inside a <code>node_modules</code>
hierarchy, then the top-most <code>node_modules</code> folder is treated as the
root of the search tree.</p>

<p>其次，如果调用<code>require()</code>的文件已经位于一个<code>node_modules</code>层次中，最上级的<code>node_modules</code>目录将被作为搜索的根。</p>

<p>For example, if the file at
<code>'/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js'</code>
called <code>require('asdf.js')</code>, then node would search the following
locations:</p>

<p>例如，如果文件<code>'/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js'</code>调用<code>require('asdf.js')</code>，node会在下面的位置进行搜索：</p>

<ul><li><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/asdf.js</code></li><li><code>/home/ry/projects/foo/node_modules/bar/node_modules/asdf.js</code></li><li><code>/home/ry/projects/foo/node_modules/asdf.js</code></li></ul>

<h3 id="folders_as_Modules_">Folders as Modules 目录作为模块</h3>

<p>It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.
There are three ways in which a folder may be passed to <code>require()</code> as
an argument.</p>

<p>很方便将程序或库组织成自包含的目录，并提供一个单独的入口指向那个库。有三种方式可以将一个子目录作为参数传递给 <code>require()</code> 。</p>

<p>The first is to create a <code>package.json</code> file in the root of the folder,
which specifies a <code>main</code> module.  An example package.json file might
look like this:</p>

<p>第一种方法是在目录的根下创建一个名为<code>package.json</code>的文件，它指定了一个<code>main</code> 模块。一个package.jso文件的例子如下面所示：</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }</code></pre>

<p>If this was in a folder at <code>./some-library</code>, then
<code>require('./some-library')</code> would attempt to load
<code>./some-library/lib/some-library.js</code>.</p>

<p>如果此文件位于<code>./some-library</code>目录中，<code>require('./some-library')</code>将试图加载文件<code>./some-library/lib/some-library.js</code>。</p>

<p>This is the extent of Node's awareness of package.json files.</p>

<p>这是Node感知package.json文件的范围。</p>

<p>If there is no package.json file present in the directory, then node
will attempt to load an <code>index.js</code> or <code>index.node</code> file out of that
directory.  For example, if there was no package.json file in the above
example, then <code>require('./some-library')</code> would attempt to load:</p>

<p>如果在目录中没有package.json文件，node将试图在该目录中加载<code>index.js</code> 或 <code>index.node</code>文件。例如，在上面的例子中没有 package.json文件，<code>require('./some-library')</code>将试图加载：</p>

<ul><li><code>./some-library/index.js</code></li><li><code>./some-library/index.node</code></li></ul>

<h3 id="caching_">Caching 缓存</h3>

<p>Modules are cached after the first time they are loaded.  This means
(among other things) that every call to <code>require('foo')</code> will get
exactly the same object returned, if it would resolve to the same file.</p>

<p>模块在第一次加载后将被缓存。这意味着（类似其他缓存）每次调用<code>require('foo')</code>如果解析到相同的文件，那么将返回同一个对象。</p>

<h3 id="all_Together..._...">All Together... 总结一下...</h3>

<p>To get the exact filename that will be loaded when <code>require()</code> is called, use
the <code>require.resolve()</code> function.</p>

<p>可使用<code>require.resolve()</code>函数，获得调用<code>require()</code>时将加载的准确的文件名。</p>

<p>Putting together all of the above, here is the high-level algorithm
in pseudocode of what require.resolve does:</p>

<p>综上所述，这里以伪代码的形式给出require.resolve的算法逻辑：</p>

<pre><code>require(X)
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with `./` or `/`,
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. LOAD_AS_FILE(X/index)

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
6. return DIRS</code></pre>

<h3 id="loading_from_the_require.paths_Folders_require.paths_">Loading from the `require.paths` Folders 从`require.paths`目录中加载</h3>

<p>In node, <code>require.paths</code> is an array of strings that represent paths to
be searched for modules when they are not prefixed with <code>'/'</code>, <code>'./'</code>, or
<code>'../'</code>.  For example, if require.paths were set to:</p>

<p>在node中，<code>require.paths</code>是一个保存模块搜索路径的字符串数组。当模块不以<code>'/'</code>，<code>'./'</code>或<code>'../'</code>为前缀时，将从此数组中的路径里进行搜索。例如，如果require.paths如下设置：</p>

<pre><code>[ '/home/micheil/.node_modules',
  '/usr/local/lib/node_modules' ]</code></pre>

<p>Then calling <code>require('bar/baz.js')</code> would search the following
locations:</p>

<p>当调用<code>require('bar/baz.js')</code>时将搜索下列位置：</p>

<ul><li>1: <code>'/home/micheil/.node_modules/bar/baz.js'</code></li><li>2: <code>'/usr/local/lib/node_modules/bar/baz.js'</code></li></ul>

<p>The <code>require.paths</code> array can be mutated at run time to alter this
behavior.</p>

<p>可以在运行时改变<code>require.paths</code>数组的内容，以改变路径搜索行为。</p>

<p>It is set initially from the <code>NODE_PATH</code> environment variable, which is
a colon-delimited list of absolute paths.  In the previous example,
the <code>NODE_PATH</code> environment variable might have been set to:</p>

<p>此数组使用<code>NODE_PATH</code>环境变量进行初始化，此环境变量是冒号分割的路径列表。在之前的例子中，<code>NODE_PATH</code>环境变量被设置为如下内容：</p>

<pre><code>/home/micheil/.node_modules:/usr/local/lib/node_modules</code></pre>

<p>Loading from the <code>require.paths</code> locations is only performed if the
module could not be found using the <code>node_modules</code> algorithm above.
Global modules are lower priority than bundled dependencies.</p>

<p>只有当使用上面介绍的<code>node_modules</code>算法无法找到模块时，才会从<code>require.paths</code>地址里进行加载。全局模块比绑定抵赖的模块优先级低。</p>

<h4 id="_Note_Please_Avoid_Modifying_require.paths_requires.paths_">**Note:** Please Avoid Modifying `require.paths` **注意：** 请不要修改`requires.paths`</h4>

<p>For compatibility reasons, <code>require.paths</code> is still given first priority
in the module lookup process.  However, it may disappear in a future
release.</p>

<p>由于兼容性的原因，<code>require.paths</code>仍然在模块查询过程中处于第一优先级。然而，在未来发布的版本中这个问题将被解决。</p>

<p>While it seemed like a good idea at the time, and enabled a lot of
useful experimentation, in practice a mutable <code>require.paths</code> list is
often a troublesome source of confusion and headaches.</p>

<p>虽然在当时看起来这是个好注意，可以支持很多有用的实验手段。但在实践中发现，修改<code>require.paths</code>列表往往是造成混乱和麻烦的源头。</p>

<h5 id="setting_require.paths_to_some_other_value_does_nothing._require.paths_">Setting `require.paths` to some other value does nothing. 将`require.paths`设为其他值不会产生任何作用</h5>

<p>This does not do what one might expect:</p>

<p>下述做法不会其他你期望的任何效果：</p>

<pre><code>require.paths = [ '/usr/lib/node' ];</code></pre>

<p>All that does is lose the reference to the <em>actual</em> node module lookup
paths, and create a new reference to some other thing that isn't used
for anything.</p>

<p>这么做将会丢失对<em>真正的</em>模块搜索路径列表对象的引用，同时指向了一个新创建的对象，而这个对象将不会其任何作用。</p>

<h5 id="putting_relative_paths_in_require.paths_is..._weird._require.paths_">Putting relative paths in `require.paths` is... weird.  不建议在`require.paths`中发入相对路径</h5>

<p>If you do this:</p>

<p>如果你这样做：</p>

<pre><code>require.paths.push('./lib');</code></pre>

<p>then it does <em>not</em> add the full resolved path to where <code>./lib</code>
is on the filesystem.  Instead, it literally adds <code>'./lib'</code>,
meaning that if you do <code>require('y.js')</code> in <code>/a/b/x.js</code>, then it'll look
in <code>/a/b/lib/y.js</code>.  If you then did <code>require('y.js')</code> in
<code>/l/m/n/o/p.js</code>, then it'd look in <code>/l/m/n/o/lib/y.js</code>.</p>

<p>这样只会添加<code>'./lib'</code>字符串到搜索路径列表，而<em>不会</em>解析<code>./lib</code>在文件系统中的绝对路径。这意味着如果你在<code>/a/b/x.js</code>中调用<code>require('y.js')</code>，将找到<code>/a/b/lib/y.js</code>。而如果你在<code>/l/m/n/o/p.js</code>中调用<code>require('y.js')</code>，将找到<code>/l/m/n/o/lib/y.js</code>。</p>

<p>In practice, people have used this as an ad hoc way to bundle
dependencies, but this technique is brittle.</p>

<p>在实践中，有用户使用这种特别的方式来实现绑定依赖，但这种方式是很脆弱的。</p>

<h5 id="zero_Isolation_">Zero Isolation 零隔离</h5>

<p>There is (by regrettable design), only one <code>require.paths</code> array used by
all modules.</p>

<p>由于设计的失误，所有模块都共享同一个<code>require.paths</code>数组。</p>

<p>As a result, if one node program comes to rely on this behavior, it may
permanently and subtly alter the behavior of all other node programs in
the same process.  As the application stack grows, we tend to assemble
functionality, and it is a problem with those parts interact in ways
that are difficult to predict.</p>

<p>造成的结果是，如果一个node程序依赖于这种行为，它将永久的并且隐蔽的改变处在同个进程内的所有其他node程序的行为。一旦应用程序变大，我们往往进行功能集成，各部分功能以不可预料的方式互相影响将成为问题。</p>

<h2 id="addenda_Package_Manager_Tips_">Addenda: Package Manager Tips 附录：包管理技巧</h2>

<p>The semantics of Node's <code>require()</code> function were designed to be general
enough to support a number of sane directory structures. Package manager
programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to
build native packages from Node modules without modification.</p>

<p>Node的<code>require()</code>函数的语义被设计的足够通用化，以支持各种常规目录结构。包管理程序如 <code>dpkg</code>，<code>rpm</code>和<code>npm</code>将不用修改就能够从Node模块构建本地包。</p>

<p>Below we give a suggested directory structure that could work:</p>

<p>接下来我们将给你一个可行的目录结构建议：</p>

<p>Let's say that we wanted to have the folder at
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a
specific version of a package.</p>

<p>假设我们希望将一个包的指定版本放在<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>目录中。</p>

<p>Packages can depend on one another. In order to install package <code>foo</code>, you
may have to install a specific version of package <code>bar</code>.  The <code>bar</code> package
may itself have dependencies, and in some cases, these dependencies may even
collide or form cycles.</p>

<p>包可以依赖于其他包。为了安装包<code>foo</code>，可能需要安装包<code>bar</code>的一个指定版本。包<code>bar</code>也可能有依赖关系，在一些情况下依赖关系可能发生冲突或形成循环。</p>

<p>Since Node looks up the <code>realpath</code> of any modules it loads (that is,
resolves symlinks), and then looks for their dependencies in the
<code>node_modules</code> folders as described above, this situation is very simple to
resolve with the following architecture:</p>

<p>因为Node会查找它所加载的模块的<code>真实路径</code>（也就是说会解析符号链接），然后按照上文描述的方式在<code>node_modules</code>目录中寻找依赖关系，所以可以使用如下的目录结构解决这个问题：</p>

<ul><li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.
<code>/usr/lib/node/foo/1.2.3/</code> - 包<code>foo</code>的1.2.3版本内容。</li><li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>
depends on.
<code>/usr/lib/node/bar/4.3.2/</code> - 包<code>foo</code>依赖的包<code>bar</code>的内容。</li><li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.
<code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - 指向<code>/usr/lib/node/bar/4.3.2/</code>的符号链接。</li><li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code>bar</code> depends on.
<code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - 指向包<code>bar</code>所依赖的包的符号链接。</li></ul>

<p>Thus, even if a cycle is encountered, or if there are dependency
conflicts, every module will be able to get a version of its dependency
that it can use.</p>

<p>因此即便存在循环依赖或依赖冲突，每个模块还是可以获得他所依赖的包的一个可用版本。</p>

<p>When the code in the <code>foo</code> package does <code>require('bar')</code>, it will get the
version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Then, when the code in the <code>bar</code> package calls <code>require('quux')</code>, it'll get
the version that is symlinked into
<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>

<p>当包<code>foo</code>中的代码调用<code>require('bar')</code>，将获得符号链接<code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>指向的版本。同样，当包<code>bar</code>中的代码调用<code>require('queue')</code>，降火的符号链接<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>指向的版本。</p>

<p>Furthermore, to make the module lookup process even more optimal, rather
than putting packages directly in <code>/usr/lib/node</code>, we could put them in
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then node will not bother
looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p>

<p>为了进一步优化模块搜索过程，不要将包直接放在<code>/usr/lib/node</code>目录中，而是将它们放在<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>目录中。这样在依赖的包找不到的情况下，就不会一直寻找到<code>/usr/node_modules</code>目录或<code>/node_modules</code>目录中了。</p>

<p>In order to make modules available to the node REPL, it might be useful to
also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment
variable.  Since the module lookups using <code>node_modules</code> folders are all
relative, and based on the real path of the files making the calls to
<code>require()</code>, the packages themselves can be anywhere.</p>

<p>为了使模块在node REPL中可用，你可能需要将<code>/usr/lib/node_modules</code>目录加入到<code>$NODE_PATH</code>环境变量中。由于在<code>node_modules</code>目录中搜索模块使用的是相对路径，基于调用<code>require()</code>的文件所在真实路径，因此包本身可以放在任何位置。
## Addons  扩展插件</p>

<p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:</p>

<p>扩展插件（Addons）是动态链接的共享对象，这些对象提供了使用C/C++类库的能力。由于涉及了多个类库导致了这类API目前比较繁杂，主要包括下述几个主要类库：</p>

<ul><li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
creating objects, calling functions, etc.  Documented mostly in the
<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source tree).</p><p>V8 JavaScript，C++类库，作为JavaScript的接口类，主要用于创建对象、调用方法等功能。大部分功能在头文件<code>v8.h</code> （在node文件夹下的路径为<code>deps/v8/include/v8.h</code>）中有详细文档。</p></li><li><p>libev, C event loop library. Anytime one needs to wait for a file
descriptor to become readable, wait for a timer, or wait for a signal to
received one will need to interface with libev.  That is, if you perform
any I/O, libev will need to be used.  Node uses the <code>EV_DEFAULT</code> event
loop.  Documentation can be found <a href="http://cvs.schmorp.de/libev/ev.html">here</a>.</p><p>libev，基于C的事件循环库。当需要等待文件描述（file descriptor）为可读时，等待定时器时，或者等待接受信号时，会需要调用libev库。也可以说，任何IO操作都需要调用libev库。Node使用<code>EV_DEFAULT</code>事件循环机制。在<a href="http://cvs.schmorp.de/libev/ev.html">这里</a>可以查阅相关文档。</p></li><li><p>libeio, C thread pool library. Used to execute blocking POSIX system
calls asynchronously. Mostly wrappers already exist for such calls, in
<code>src/file.cc</code> so you will probably not need to use it. If you do need it,
look at the header file <code>deps/libeio/eio.h</code>.</p><p>libeio，基于C的线程池库，用于以异步方式执行阻塞式POSIX系统调用。因为大部分这类调用都在<code>src/file.cc</code>中被封装了，你一般不需要直接使用libeio。如果必须使用该类库时，可查看其头文件<code>deps/libeio/eio.h</code>。</p></li><li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>
class which you will likely want to derive from.</p><p>内部Node库。在该库中，最重要的类是我们可能用于进行派生的<code>node::ObjectWrap</code>基类。</p></li><li><p>Others. Look in <code>deps/</code> for what else is available.</p><p>其他的一些类库同样可以在<code>deps/</code> 中找到。</p></li></ul>

<p>Node statically compiles all its dependencies into the executable. When
compiling your module, you don't need to worry about linking to any of these
libraries.</p>

<p>Node已将所有依赖关系静态地编译成可执行文件，因此我们在编译自己的组件时不需要担心和这些类库的链接问题。</p>

<p>To get started let's make a small Addon which does the following except in
C++:</p>

<p>让我们着手编写一个Addon的小例子，来达到如下模块同样的效果：</p>

<pre><code>exports.hello = 'world';</code></pre>

<p>To get started we create a file <code>hello.cc</code>:</p>

<p>首先我们需要创建一个<code>hello.cc</code>文件：</p>

<pre><code>#include &lt;v8.h&gt;

using namespace v8;

extern "C" void
init (Handle&lt;Object&gt; target)
{
  HandleScope scope;
  target-&gt;Set(String::New("hello"), String::New("world"));
}</code></pre>

<p>This source code needs to be built into <code>hello.node</code>, the binary Addon. To
do this we create a file called <code>wscript</code> which is python code and looks
like this:</p>

<p>这些源码会编译成一个二进制的Addon文件<code>hello.node</code>。为此我们用python编写如下的名为<code>wscript</code>的文件：</p>

<pre><code>srcdir = '.'
blddir = 'build'
VERSION = '0.0.1'

def set_options(opt):
  opt.tool_options('compiler_cxx')

def configure(conf):
  conf.check_tool('compiler_cxx')
  conf.check_tool('node_addon')

def build(bld):
  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
  obj.target = 'hello'
  obj.source = 'hello.cc'</code></pre>

<p>Running <code>node-waf configure build</code> will create a file
<code>build/default/hello.node</code> which is our Addon.</p>

<p>运行<code>node-waf configure build</code>，我们就创建了一个Addon实例<code>build/default/hello.node</code>。</p>

<p><code>node-waf</code> is just <a href="http://code.google.com/p/waf">WAF</a>, the python-based build system. <code>node-waf</code> is
provided for the ease of users.</p>

<p><code>node-waf</code>就是<a href="http://code.google.com/p/waf">WAF</a>,，一种基于python的编译系统，而<code>node-waf</code>更加易于使用。</p>

<p>All Node addons must export a function called <code>init</code> with this signature:</p>

<p>另外，在Node中任何的Addon必须使用输出一个如下声明的<code>init</code>函数：</p>

<pre><code>extern 'C' void init (Handle&lt;Object&gt; target)</code></pre>

<p>For the moment, that is all the documentation on addons. Please see
<a href="http://github.com/ry/node_postgres">http://github.com/ry/node_postgres</a> for a real example.</p>

<p>目前关于addon的所有文档就是这些。另外，在<a href="http://github.com/ry/node_postgres">http://github.com/ry/node_postgres</a>中还提供了一个Addon的实例。
## process 进程</p>

<p>The <code>process</code> object is a global object and can be accessed from anywhere.</p>

<p><code>process</code>对象是一个全局对象，可以在任何地方访问它。</p>

<p>It is an instance of <code>EventEmitter</code>.</p>

<p>它是<code>EventEmitter</code>事件触发器类型的一个实例。</p>

<h3 id="event_exit_exit_">Event: 'exit' 事件：'exit'</h3>

<p><code>function () {}</code></p>

<p>Emitted when the process is about to exit.  This is a good hook to perform
constant time checks of the module's state (like for unit tests).  The main
event loop will no longer be run after the 'exit' callback finishes, so
timers may not be scheduled.</p>

<p>当进程对象要退出时会触发此方法，这是检查模块状态（比如单元测试）的好时机。当'exit'被调用完成后主事件循环将终止，所以计时器将不会按计划执行。</p>

<p>Example of listening for <code>exit</code>:</p>

<p>监听<code>exit</code>行为的示例：</p>

<pre><code>process.on('exit', function () {
  process.nextTick(function () {
   console.log('This will not run');
  });
  console.log('About to exit.');
});</code></pre>

<h3 id="event_uncaughtException_uncaughtException_">Event: 'uncaughtException' 事件：'uncaughtException'</h3>

<p><code>function (err) { }</code></p>

<p>Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.</p>

<p>当一个异常信息一路冒出到事件循环时，该方法被触发。如果该异常有一个监听器，那么默认的行为（即打印一个堆栈轨迹并退出）将不会发生。</p>

<p>Example of listening for <code>uncaughtException</code>:</p>

<p>监听<code>uncaughtException</code>事件的示例：</p>

<pre><code>process.on('uncaughtException', function (err) {
  console.log('Caught exception: ' + err);
});

setTimeout(function () {
  console.log('This will still run.');
}, 500);

// Intentionally cause an exception, but don't catch it.
nonexistentFunc();
console.log('This will not run.');</code></pre>

<p>Note that <code>uncaughtException</code> is a very crude mechanism for exception
handling.  Using try / catch in your program will give you more control over
your program's flow.  Especially for server programs that are designed to
stay running forever, <code>uncaughtException</code> can be a useful safety mechanism.</p>

<p>注意：就异常处理来说，<code>uncaughtException</code>是一个很粗糙的机制。在程序中使用try/catch可以更好好控制程序流程。而在服务器编程中，因为要持续运行，<code>uncaughtException</code>还是一个很有用的安全机制。</p>

<h3 id="signal_Events_">Signal Events 信号事件</h3>

<p><code>function () {}</code></p>

<p>Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGUSR1, etc.</p>

<p>该事件会在进程接收到一个信号时被触发。可参见sigaction(2)中的标准POSIX信号名称列表，比如SIGINT，SIGUSR1等等。</p>

<p>Example of listening for <code>SIGINT</code>:</p>

<p>监听 <code>SIGINT</code>的示例：</p>

<pre><code>// Start reading from stdin so we don't exit.
process.stdin.resume();

process.on('SIGINT', function () {
  console.log('Got SIGINT.  Press Control-D to exit.');
});</code></pre>

<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal
programs.</p>

<p>在大多数终端程序中，一个简易发送<code>SIGINT</code>信号的方法是在使用<code>Control-C</code>命令操作。</p>

<h3 id="process.stdout">process.stdout</h3>

<p>A <code>Writable Stream</code> to <code>stdout</code>.</p>

<p>一个指向标准输出<code>stdout</code>的<code>Writable Stream</code>可写流。</p>

<p>Example: the definition of <code>console.log</code></p>

<p>示例：<code>console.log</code>的定义。</p>

<pre><code>console.log = function (d) {
  process.stdout.write(d + '\n');
};</code></pre>

<h3 id="process.stderr">process.stderr</h3>

<p>A writable stream to stderr. Writes on this stream are blocking.</p>

<p>一个指向错误的可写流，在这个流上的写操作是阻塞式的。</p>

<h3 id="process.stdin">process.stdin</h3>

<p>A <code>Readable Stream</code> for stdin. The stdin stream is paused by default, so one
must call <code>process.stdin.resume()</code> to read from it.</p>

<p>一个到标准输入的可读流<code>Readable Stream</code>。默认情况下标准输入流是暂停的，要从中读取内容需要调用方法<code>process.stdin.resume()</code>。</p>

<p>Example of opening standard input and listening for both events:</p>

<p>示例：打开标准输入与监听两个事件：</p>

<pre><code>process.stdin.resume();
process.stdin.setEncoding('utf8');

process.stdin.on('data', function (chunk) {
  process.stdout.write('data: ' + chunk);
});

process.stdin.on('end', function () {
  process.stdout.write('end');
});</code></pre>

<h3 id="process.argv">process.argv</h3>

<p>An array containing the command line arguments.  The first element will be
'node', the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.</p>

<p>一个包含命令行参数的数组。第一个元素是'node'，第二个元素是JavaScript文件的文件名。接下来的元素则是附加的命令行参数。</p>

<pre><code>// print process.argv
process.argv.forEach(function (val, index, array) {
  console.log(index + ': ' + val);
});</code></pre>

<p>This will generate:</p>

<p>这产生如下的信息：</p>

<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>

<h3 id="process.execPath">process.execPath</h3>

<p>This is the absolute pathname of the executable that started the process.</p>

<p>这是一个启动该进程的可执行程序的绝对路径名。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>/usr/local/bin/node</code></pre>

<h3 id="process.chdir">process.chdir(directory)</h3>

<p>Changes the current working directory of the process or throws an exception if that fails.</p>

<p>改变进程的当前工作目录，如果操作失败则抛出异常。</p>

<pre><code>console.log('Starting directory: ' + process.cwd());
try {
  process.chdir('/tmp');
  console.log('New directory: ' + process.cwd());
}
catch (err) {
  console.log('chdir: ' + err);
}</code></pre>

<h3 id="process.cwd">process.cwd()</h3>

<p>Returns the current working directory of the process.</p>

<p>返回进程的当前工作目录。</p>

<pre><code>console.log('Current directory: ' + process.cwd());</code></pre>

<h3 id="process.env">process.env</h3>

<p>An object containing the user environment. See environ(7).</p>

<p>一个包括用户环境的对象。可参见environ(7)。</p>

<h3 id="process.exit">process.exit(code=0)</h3>

<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the
'success' code <code>0</code>.</p>

<p>用指定的<code>code</code>代码结束进程。如果不指定，退出时将使用'success'（成功）代码 <code>0</code>。</p>

<p>To exit with a 'failure' code:</p>

<p>以'failure'（失败）代码退出的示例：</p>

<pre><code>process.exit(1);</code></pre>

<p>The shell that executed node should see the exit code as 1.</p>

<p>执行node的shell会把退出代码视为1。</p>

<h3 id="process.getgid">process.getgid()</h3>

<p>Gets the group identity of the process. (See getgid(2).)
This is the numerical group id, not the group name.</p>

<p>获取进程的群组标识（详见getgid(2)）。这是一个数字的群组ID，不是群组名称。</p>

<pre><code>console.log('Current gid: ' + process.getgid());</code></pre>

<h3 id="process.setgid">process.setgid(id)</h3>

<p>Sets the group identity of the process. (See setgid(2).)  This accepts either
a numerical ID or a groupname string. If a groupname is specified, this method
blocks while resolving it to a numerical ID.</p>

<p>设置进程的群组标识（详见getgid(2)）。参数可以是一个数字ID或者群组名字符串。如果指定了一个群组名，这个方法会阻塞等待将群组名解析为数字ID。</p>

<pre><code>console.log('Current gid: ' + process.getgid());
try {
  process.setgid(501);
  console.log('New gid: ' + process.getgid());
}
catch (err) {
  console.log('Failed to set gid: ' + err);
}</code></pre>

<h3 id="process.getuid">process.getuid()</h3>

<p>Gets the user identity of the process. (See getuid(2).)
This is the numerical userid, not the username.</p>

<p>获取进程的用户ID（详见getgid(2)）。这是一个数字用户ID，不是用户名。</p>

<pre><code>console.log('Current uid: ' + process.getuid());</code></pre>

<h3 id="process.setuid">process.setuid(id)</h3>

<p>Sets the user identity of the process. (See setuid(2).)  This accepts either
a numerical ID or a username string.  If a username is specified, this method
blocks while resolving it to a numerical ID.</p>

<p>设置进程的用户ID（详见getgid(2)）。参数可以使一个数字ID或者用户名字符串。如果指定了一个用户名，那么该方法会阻塞等待将用户名解析为数字ID。</p>

<pre><code>console.log('Current uid: ' + process.getuid());
try {
  process.setuid(501);
  console.log('New uid: ' + process.getuid());
}
catch (err) {
  console.log('Failed to set uid: ' + err);
}</code></pre>

<h3 id="process.version">process.version</h3>

<p>A compiled-in property that exposes <code>NODE_VERSION</code>.</p>

<p>一个编译内置的属性，用于显示<code>NODE_VERSION</code>（Node版本）。</p>

<pre><code>console.log('Version: ' + process.version);</code></pre>

<h3 id="process.installPrefix">process.installPrefix</h3>

<p>A compiled-in property that exposes <code>NODE_PREFIX</code>.</p>

<p>一个编译内置的属性，用于显示<code>NODE_PREFIX</code>（Node安装路径前缀）。</p>

<pre><code>console.log('Prefix: ' + process.installPrefix);</code></pre>

<h3 id="process.kill">process.kill(pid, signal='SIGTERM')</h3>

<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the
string describing the signal to send.  Signal names are strings like
'SIGINT' or 'SIGUSR1'.  If omitted, the signal will be 'SIGTERM'.
See kill(2) for more information.</p>

<p>发送一个信号到进程。<code>pid</code>是进程的ID，参数<code>signal</code>是欲发送信号的字符串描述。信号名称是像'SIGINT'或者'SIGUSR1'这样的字符串。如果参数<code>signal</code>忽略，则信号为'SIGTERM'。详见kill(2)。</p>

<p>Note that just because the name of this function is <code>process.kill</code>, it is
really just a signal sender, like the <code>kill</code> system call.  The signal sent
may do something other than kill the target process.</p>

<p>注意该函数名为<code>process.kill</code>，实际上也就像<code>kill</code>系统调用一样仅仅是一个信号发送器。发送的信号可能是要终止目标进程，也可能是实现其他不同的目的。</p>

<p>Example of sending a signal to yourself:</p>

<p>一个给自己发送信号的示例：</p>

<pre><code>process.on('SIGHUP', function () {
  console.log('Got SIGHUP signal.');
});

setTimeout(function () {
  console.log('Exiting.');
  process.exit(0);
}, 100);

process.kill(process.pid, 'SIGHUP');</code></pre>

<h3 id="process.pid">process.pid</h3>

<p>The PID of the process.</p>

<p>进程的PID。</p>

<pre><code>console.log('This process is pid ' + process.pid);</code></pre>

<h3 id="process.title">process.title</h3>

<p>Getter/setter to set what is displayed in 'ps'.</p>

<p>获取或设置在'ps'命令中显示的进程的标题。</p>

<h3 id="process.platform">process.platform</h3>

<p>What platform you're running on. <code>'linux2'</code>, <code>'darwin'</code>, etc.</p>

<p>运行Node的平台信息，如'linux2'<code>，</code>'darwin'`等等。</p>

<pre><code>console.log('This platform is ' + process.platform);</code></pre>

<h3 id="process.memoryUsage">process.memoryUsage()</h3>

<p>Returns an object describing the memory usage of the Node process.</p>

<p>返回一个描述Node进程内存使用情况的对象。</p>

<pre><code>var util = require('util');

console.log(util.inspect(process.memoryUsage()));</code></pre>

<p>This will generate:</p>

<p>这会生成如下信息：</p>

<pre><code>{ rss: 4935680,
  vsize: 41893888,
  heapTotal: 1826816,
  heapUsed: 650472 }</code></pre>

<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8's memory usage.</p>

<p><code>heapTotal</code>与<code>heapUsed</code>指V8的内存使用情况。</p>

<h3 id="process.nextTick">process.nextTick(callback)</h3>

<p>On the next loop around the event loop call this callback.
This is <em>not</em> a simple alias to <code>setTimeout(fn, 0)</code>, it's much more
efficient.</p>

<p>在事件循环的下一次循环中调用callback回调函数。这<em>不是</em><code>setTimeout(fn, 0)</code>的一个别名，因为它有效率多了。</p>

<pre><code>process.nextTick(function () {
  console.log('nextTick callback');
});</code></pre>

<h3 id="process.umask">process.umask([mask])</h3>

<p>Sets or reads the process's file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if <code>mask</code> argument is
given, otherwise returns the current mask.</p>

<p>设置或者读取进程的文件模式创建掩码。子进程从父进程中继承这个掩码。如果设定了参数<code>mask</code>那么返回旧的掩码，否则返回当前的掩码。</p>

<pre><code>var oldmask, newmask = 0644;

oldmask = process.umask(newmask);
console.log('Changed umask from: ' + oldmask.toString(8) +
            ' to ' + newmask.toString(8));</code></pre>

<h2 id="util_">util 工具模块</h2>

<p>These functions are in the module <code>'util'</code>. Use <code>require('util')</code> to access
them.</p>

<p>下列函数属于<code>'util'</code>（工具）模块，可使用<code>require('util')</code>访问它们。</p>

<h3 id="util.debug">util.debug(string)</h3>

<p>A synchronous output function. Will block the process and
output <code>string</code> immediately to <code>stderr</code>.</p>

<p>这是一个同步输出函数，将<code>string</code>参数的内容实时输出到<code>stderr</code>标准错误。调用此函数时将阻塞当前进程直到输出完成。</p>

<pre><code>require('util').debug('message on stderr');</code></pre>

<h3 id="util.log">util.log(string)</h3>

<p>Output with timestamp on <code>stdout</code>.</p>

<p>将<code>string</code>参数的内容加上当前时间戳，输出到<code>stdout</code>标准输出。</p>

<pre><code>require('util').log('Timestmaped message.');</code></pre>

<h3 id="util.inspect">util.inspect(object, showHidden=false, depth=2)</h3>

<p>Return a string representation of <code>object</code>, which is useful for debugging.</p>

<p>以字符串形式返回<code>object</code>对象的结构信息，这对程序调试非常有帮助。</p>

<p>If <code>showHidden</code> is <code>true</code>, then the object's non-enumerable properties will be
shown too.</p>

<p>如果<code>showHidden</code>参数设置为<code>true</code>，则此对象的不可枚举属性也会被显示。</p>

<p>If <code>depth</code> is provided, it tells <code>inspect</code> how many times to recurse while
formatting the object. This is useful for inspecting large complicated objects.</p>

<p>可使用<code>depth</code>参数指定<code>inspect</code>函数在格式化对象信息时的递归次数。这对分析复杂对象的内部结构非常有帮助。</p>

<p>The default is to only recurse twice.  To make it recurse indefinitely, pass
in <code>null</code> for <code>depth</code>.</p>

<p>默认情况下递归两次，如果想要无限递归可将<code>depth</code>参数设为<code>null</code>。</p>

<p>Example of inspecting all properties of the <code>util</code> object:</p>

<p>显示<code>util</code>对象所有属性的例子如下：</p>

<pre><code>var util = require('util');

console.log(util.inspect(util, true, null));</code></pre>

<h3 id="util.pump">util.pump(readableStream, writableStream, [callback])</h3>

<p>Experimental</p>

<p>实验性的</p>

<p>Read the data from <code>readableStream</code> and send it to the <code>writableStream</code>.
When <code>writableStream.write(data)</code> returns <code>false</code> <code>readableStream</code> will be
paused until the <code>drain</code> event occurs on the <code>writableStream</code>. <code>callback</code> gets
an error as its only argument and is called when <code>writableStream</code> is closed or
when an error occurs.</p>

<p>从<code>readableStream</code>参数所指定的可读流中读取数据，并将其写入到<code>writableStream</code>参数所指定的可写流中。当<code>writeableStream.write(data)</code>函数调用返回为<code>false</code>时，<code>readableStream</code>流将被暂停，直到在<code>writableStream</code>流上发生<code>drain</code>事件。当<code>writableStream</code>流被关闭或发生一个错误时，<code>callback</code>回调函数被调用。此回调函数只接受一个参数用以指明所发生的错误。</p>

<h3 id="util.inherits">util.inherits(constructor, superConstructor)</h3>

<p>Inherit the prototype methods from one
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor">constructor</a>
into another.  The prototype of <code>constructor</code> will be set to a new
object created from <code>superConstructor</code>.</p>

<p>将一个<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor">构造函数</a>的原型方法继承到另一个构造函数中。<code>constructor</code>构造函数的原型将被设置为使用<code>superConstructor</code>构造函数所创建的一个新对象。</p>

<p>As an additional convenience, <code>superConstructor</code> will be accessible
through the <code>constructor.super_</code> property.</p>

<p>此方法带来的额外的好处是，可以通过<code>constructor.super_</code>属性来访问<code>superConstructor</code>构造函数。</p>

<pre><code>var util = require("util");
var events = require("events");

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit("data", data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on("data", function(data) {
    console.log('Received data: "' + data + '"');
})
stream.write("It works!"); // Received data: "It works!"</code></pre>

<h2 id="events_">Events 事件模块</h2>

<p>Many objects in Node emit events: a <code>net.Server</code> emits an event each time
a peer connects to it, a <code>fs.readStream</code> emits an event when the file is
opened. All objects which emit events are instances of <code>events.EventEmitter</code>.
You can access this module by doing: <code>require("events");</code></p>

<p>Node引擎中很多对象都会触发事件：例如<code>net.Server</code>会在每一次有客户端连接到它时触发事件，又如<code>fs.readStream</code>会在文件打开时触发事件。所有能够触发事件的对象都是<code>events.EventEmitter</code>的实例。你可以通过<code>require("events");</code>访问这个模块。</p>

<p>Typically, event names are represented by a camel-cased string, however,
there aren't any strict restrictions on that, as any string will be accepted.</p>

<p>通常情况下，事件名称采用驼峰式写法，不过目前并没有对事件名称作任何的限制，也就是说任何的字符串都可以被接受。</p>

<p>Functions can then be attached to objects, to be executed when an event
is emitted. These functions are called <em>listeners</em>.</p>

<p>可以将函数注册给对象，使其在事件触发时执行，此类函数被称作<em>监听器</em>。</p>

<h3 id="events.EventEmitter">events.EventEmitter</h3>

<p>To access the EventEmitter class, <code>require('events').EventEmitter</code>.</p>

<p>通过调用<code>require('events').EventEmitter</code>，我们可以使用事件触发器类。 </p>

<p>When an <code>EventEmitter</code> instance experiences an error, the typical action is
to emit an <code>'error'</code> event.  Error events are treated as a special case in node.
If there is no listener for it, then the default action is to print a stack
trace and exit the program.</p>

<p>当<code>EventEmitter</code>事件触发器遇到错误时，典型的处理方式是它将触发一个<code>'error'</code>事件。Error事件的特殊性在于：如果没有函数处理这个事件，它将会输出调用堆栈，并随之退出应用程序。</p>

<p>All EventEmitters emit the event <code>'newListener'</code> when new listeners are
added.</p>

<p>当新的事件监听器被添加时，所有的事件触发器都将触发名为<code>'newListener'</code>的事件。</p>

<h4 id="emitter.addListener">emitter.addListener(event, listener)</h4>

<h4 id="emitter.on">emitter.on(event, listener)</h4>

<p>Adds a listener to the end of the listeners array for the specified event.</p>

<p>将一个监听器添加到指定事件的监听器数组的末尾。</p>

<pre><code>server.on('connection', function (stream) {
  console.log('someone connected!');
});</code></pre>

<h4 id="emitter.once">emitter.once(event, listener)</h4>

<p>Adds a <strong>one time</strong> listener for the event. The listener is
invoked only the first time the event is fired, after which
it is removed.</p>

<p>为事件添加<strong>一次性</strong>的监听器。该监听器在事件第一次触发时执行，过后将被移除。</p>

<pre><code>server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});</code></pre>

<h4 id="emitter.removeListener">emitter.removeListener(event, listener)</h4>

<p>Remove a listener from the listener array for the specified event.
<strong>Caution</strong>: changes array indices in the listener array behind the listener.</p>

<p>将监听器从指定事件的监听器数组中移除出去。
<strong>小心</strong>：此操作将改变监听器数组的下标。</p>

<pre><code>var callback = function(stream) {
  console.log('someone connected!');
};
server.on('connection', callback);
// ...
server.removeListener('connection', callback);</code></pre>

<h4 id="emitter.removeAllListeners">emitter.removeAllListeners(event)</h4>

<p>Removes all listeners from the listener array for the specified event.</p>

<p>将指定事件的所有监听器从监听器数组中移除。</p>

<h4 id="emitter.setMaxListeners">emitter.setMaxListeners(n)</h4>

<p>By default EventEmitters will print a warning if more than 10 listeners are
added to it. This is a useful default which helps finding memory leaks.
Obviously not all Emitters should be limited to 10. This function allows
that to be increased. Set to zero for unlimited.</p>

<p>默认情况下当事件触发器注册了超过10个以上的监听器时系统会打印警告信息，这个默认配置将有助于你查找内存泄露问题。很显然并不是所有的事件触发器都需要进行10个监听器的限制，此函数允许你手动设置该数量值，如果值为0意味值没有限制。</p>

<h4 id="emitter.listeners">emitter.listeners(event)</h4>

<p>Returns an array of listeners for the specified event. This array can be
manipulated, e.g. to remove listeners.</p>

<p>返回指定事件的监听器数组对象，你可以对该数组进行操作，比如说删除监听器等。</p>

<pre><code>server.on('connection', function (stream) {
  console.log('someone connected!');
});
console.log(util.inspect(server.listeners('connection')); // [ [Function] ]</code></pre>

<h4 id="emitter.emit">emitter.emit(event, [arg1], [arg2], [...])</h4>

<p>Execute each of the listeners in order with the supplied arguments.</p>

<p>以提供的参数作为监听器函数的参数，顺序执行监听器列表中的每个监听器函数。</p>

<h4 id="event_newListener_newListener_">Event: 'newListener' 事件：'newListener'</h4>

<p><code>function (event, listener) { }</code></p>

<p>This event is emitted any time someone adds a new listener.</p>

<p>任何时候只要新的监听器被添加时该事件就会触发。</p>

<h2 id="buffers_">Buffers  缓冲器</h2>

<p>Pure Javascript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it's necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.</p>

<p>纯Javascript语言是Unicode友好性的，但是难以处理二进制数据。在处理TCP流和文件系统时经常需要操作字节流。Node提供了一些列机制，用于操作、创建、以及消耗（consuming）字节流。</p>

<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.</p>

<p>在实例化的<code>Buffer</code>类中存储了原始数据。<code>Buffer</code>类似于一个整数数组，但<code>Buffer</code>对应了在V8堆（the V8 heap）外的原始存储空间分配。一旦创建了<code>Buffer</code>实例，则无法改变其大小。</p>

<p>The <code>Buffer</code> object is global.</p>

<p>另外，<code>Buffer</code>是一个全局对象。</p>

<p>Converting between Buffers and JavaScript string objects requires an explicit encoding
method.  Here are the different string encodings;</p>

<p>在缓冲器（Buffers）和JavaScript间进行字符串的转换需要调用特定的编码方法。如下列举了不同的编码方法：</p>

<ul><li><p><code>'ascii'</code> - for 7 bit ASCII data only.  This encoding method is very fast, and will
strip the high bit if set.</p><p><code>'ascii'</code> - 仅对应7位的ASCII数据。虽然这种编码方式非常迅速，并且如果设置了最高位，则会将其移去。</p></li><li><p><code>'utf8'</code> - Multi byte encoded Unicode characters.  Many web pages and other document formats use UTF-8.</p><p><code>'utf8'</code> - 对应多字节编码Unicode字符。大量网页和其他文件格式使用这类编码方式。</p></li><li><p><code>'ucs2'</code> - 2-bytes, little endian encoded Unicode characters. It can encode
only BMP(Basic Multilingual Plane, U+0000 - U+FFFF).</p><p><code>'ucs2'</code> - 2字节的，低字节序编码Unicode字符。只能编码BMP（第零平面，U+0000 - U+FFFF）字符。</p></li><li><p><code>'base64'</code> - Base64 string encoding.</p><p><code>'base64'</code> - Base64 字符串编码.</p></li><li><p><code>'binary'</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is depreciated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p><p><code>'binary'</code> - 仅使用每个字符的头8位将原始的二进制信息进行编码。在需使用<code>Buffer</code>的情况下，应该尽量避免使用这个已经过时的编码方式。而且，这个编码方式不会出现在未来版本的Node中。</p></li><li><p><code>'hex'</code> - Encode each byte as two hexidecimal characters.</p><p><code>'hex'</code> - 将一个字节编码为两个16进制字符。</p></li></ul>

<h3 id="new_Buffer">new Buffer(size)</h3>

<p>Allocates a new buffer of <code>size</code> octets.</p>

<p>分配给一个新创建的buffer实例一个大小为<code>size</code>字节的空间。</p>

<h3 id="new_Buffer">new Buffer(array)</h3>

<p>Allocates a new buffer using an <code>array</code> of octets.</p>

<p>使用<code>array</code>的空间创建一个buffer实例。</p>

<h3 id="new_Buffer">new Buffer(str, encoding='utf8')</h3>

<p>Allocates a new buffer containing the given <code>str</code>.</p>

<p>创建一个包含给定<code>str</code>的buffer实例。</p>

<h3 id="buffer.write">buffer.write(string, offset=0, encoding='utf8')</h3>

<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding. Returns
number of octets written.  If <code>buffer</code> did not contain enough space to fit
the entire string, it will write a partial amount of the string. In the case
of <code>'utf8'</code> encoding, the method will not write partial characters.</p>

<p>通过给定的编码方式把<code>string</code>写入到buffer的<code>offset</code>（偏移地址）中，并且返回写入的字节数。如果当前的<code>buffer</code>没有足够存储空间，字符串会部分地保存在<code>buffer</code>中，而不是整串字符。需要注意的是，如果使用<code>'utf8'</code>进行编码，该方法不会对零散的字符进行编写。</p>

<p>Example: write a utf8 string into a buffer, then print it</p>

<p>例如：将一串utf8格式的字符串写入Buffer，然后输出：</p>

<pre><code>buf = new Buffer(256);
len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(len + " bytes: " + buf.toString('utf8', 0, len));

// 12 bytes: ½ + ¼ = ¾</code></pre>

<h3 id="buffer.toString">buffer.toString(encoding, start=0, end=buffer.length)</h3>

<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
beginning at <code>start</code> and ending at <code>end</code>.</p>

<p>对缓冲器中的以<code>encoding</code>方式编码的，以<code>start</code>标识符开始，以<code>end</code>标识符结尾的缓冲数据进行解码，并输出字符串。</p>

<p>See <code>buffer.write()</code> example, above.</p>

<p>参见上文的<code>buffer.write()</code>例子。</p>

<h3 id="buffer_index_">buffer[index]</h3>

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>

<p>获取或者设置位于<code>index</code>字节的值。由于返回值为单个的字节，因此其范围应该在<code>0x00</code> 到 <code>0xFF</code>（16进制）或者<code>0</code> and <code>255</code>（10进制）之间</p>

<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>

<p>例如：通过每次仅输入一个字符的方式将整串ASCII字符录入Buffer中：</p>

<pre><code>str = "node.js";
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>

<h3 id="buffer.isBuffer">Buffer.isBuffer(obj)</h3>

<p>Tests if <code>obj</code> is a <code>Buffer</code>.</p>

<p>验证<code>obj</code>的类别是否为<code>Buffer</code>类。</p>

<h3 id="buffer.byteLength">Buffer.byteLength(string, encoding='utf8')</h3>

<p>Gives the actual byte length of a string.  This is not the same as
<code>String.prototype.length</code> since that returns the number of <em>characters</em> in a
string.</p>

<p>返回字符串长度的实际值。与<code>String.prototype.length</code>的区别之处在于该方法返回的是字符串中<em>characters</em>的个数。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>str = '\u00bd + \u00bc = \u00be';

console.log(str + ": " + str.length + " characters, " +
  Buffer.byteLength(str, 'utf8') + " bytes");

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>

<h3 id="buffer.length">buffer.length</h3>

<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.</p>

<p>返回Buffer占用的字节数。需要注意的是，<code>length</code>并非其内容占的大小，而是指分配给Buffer实例的存储空间的大小，因此该值不会随Buffer内容的变化而变化。</p>

<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write("some string", "ascii", 0);
console.log(buf.length);

// 1234
// 1234</code></pre>

<h3 id="buffer.copy">buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3>

<p>Does a memcpy() between buffers.</p>

<p>在两个Buffer之间进行memcpy() 操作。</p>

<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>

<p>例如：创建2个Buffer实例，然后将<code>buf1</code>中第16字节到第19字节间的信息复制到<code>buf2</code>中，并使在<code>buf2</code>中新的字符串首字符位于第8字节：</p>

<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>

<h3 id="buffer.slice">buffer.slice(start, end=buffer.length)</h3>

<p>Returns a new buffer which references the
same memory as the old, but offset and cropped by the <code>start</code> and <code>end</code>
indexes.</p>

<p>返回一个和原Buffer引用相同存储空间的新Buffer，但是新Buffer中的偏移地址截取了原Buffer偏移地址中自<code>start</code>到<code>end</code>的部分。</p>

<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>

<p><strong>特别注意：通过修改新的Buffer切片（slice）中的内容同样会修改存储在原Buffer中的信息！</strong></p>

<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one byte
from the original Buffer.</p>

<p>例如：建立一个ASCII码型的字母表，再建立一个切片，并在原Buffer中修改一个字节：</p>

<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length));

// abc
// !bc</code></pre>

<h2 id="streams_">Streams 流</h2>

<p>A stream is an abstract interface implemented by various objects in Node.
For example a request to an HTTP server is a stream, as is stdout. Streams
are readable, writable, or both. All streams are instances of <code>EventEmitter</code>.</p>

<p>在Node中，Stream（流）是一个由不同对象实现的抽象接口。例如请求HTTP服务器的request是一个流，类似于stdout（标准输出）。流可以是可读的，可写的，或者既可读又可写。所有流都是<code>EventEmitter</code>的实例。</p>

<h2 id="readable_Stream_">Readable Stream 可读流</h2>

<p>A <code>Readable Stream</code> has the following methods, members, and events.</p>

<p>一个<code>可读流</code>具有下述的方法、成员、及事件。</p>

<h3 id="event_data_data_">Event: 'data' 事件：'data'</h3>

<p><code>function (data) { }</code></p>

<p>The <code>'data'</code> event emits either a <code>Buffer</code> (by default) or a string if
<code>setEncoding()</code> was used.</p>

<p><code>'data'</code>事件的回调函数参数默认情况下是一个<code>Buffer</code>对象。如果使用了<code>setEncoding()</code> 则参数为一个字符串。</p>

<h3 id="event_end_end_">Event: 'end' 事件：'end'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the stream has received an EOF (FIN in TCP terminology).
Indicates that no more <code>'data'</code> events will happen. If the stream is also
writable, it may be possible to continue writing.</p>

<p>当流中接收到EOF（TCP中为FIN）时此事件被触发，表示流的读取已经结束，不会再发生任何<code>'data'</code>事件。如果流同时也是可写的，那它还可以继续写入。</p>

<h3 id="event_error_error_">Event: 'error' 事件：'error'</h3>

<p><code>function (exception) { }</code></p>

<p>Emitted if there was an error receiving data.</p>

<p>接收数据的过程中发生任何错误时，此事件被触发。</p>

<h3 id="event_close_close_">Event: 'close' 事件：'close'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the underlying file descriptor has been closed. Not all streams
will emit this.  (For example, an incoming HTTP request will not emit
<code>'close'</code>.)</p>

<p>当底层的文件描述符被关闭时触发此事件，并不是所有流都会触发这个事件。（例如，一个连接进入的HTTP request流就不会触发<code>'close'</code>事件。）</p>

<h3 id="event_fd_fd_">Event: 'fd' 事件：'fd'</h3>

<p><code>function (fd) { }</code></p>

<p>Emitted when a file descriptor is received on the stream. Only UNIX streams
support this functionality; all others will simply never emit this event.</p>

<p>当在流中接收到一个文件描述符时触发此事件。只有UNIX流支持这个功能，其他类型的流均不会触发此事件。</p>

<h3 id="stream.readable">stream.readable</h3>

<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occurred, the stream came to an <code>'end'</code>, or <code>destroy()</code> was called.</p>

<p>这是一个布尔值，默认值为<code>true</code>。当<code>'error'</code>事件或<code>'end'</code>事件发生后，或者<code>destroy()</code>被调用后，这个属性将变为<code>false</code>。</p>

<h3 id="stream.setEncoding">stream.setEncoding(encoding)</h3>

<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be
<code>'utf8'</code>, <code>'ascii'</code>, or <code>'base64'</code>.</p>

<p>调用此方法会影响<code>'data'</code>事件的回调函数参数形式，默认为<code>Buffer</code>对象，调用此方法后为字符串。<code>encoding</code>参数可以是<code>'utf8'</code>、<code>'ascii'</code>、或<code>'base64'</code>。</p>

<h3 id="stream.pause">stream.pause()</h3>

<p>Pauses the incoming <code>'data'</code> events.</p>

<p>暂停<code>'data'</code>事件的触发。</p>

<h3 id="stream.resume">stream.resume()</h3>

<p>Resumes the incoming <code>'data'</code> events after a <code>pause()</code>.</p>

<p>恢复被<code>pause()</code>调用暂停的<code>'data'</code>事件触发。</p>

<h3 id="stream.destroy">stream.destroy()</h3>

<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>

<p>关闭底层的文件描述符。流上将不会再触发任何事件。</p>

<h3 id="stream.destroySoon">stream.destroySoon()</h3>

<p>After the write queue is drained, close the file descriptor.</p>

<p>在写队列清空后（所有写操作完成后），关闭文件描述符。</p>

<h3 id="stream.pipe">stream.pipe(destination, [options])</h3>

<p>This is a <code>Stream.prototype</code> method available on all <code>Stream</code>s.</p>

<p>这是<code>Stream.prototype</code>（Stream原型对象）的一个方法，对所有<code>Stream</code>对象有效。</p>

<p>Connects this read stream to <code>destination</code> WriteStream. Incoming
data on this stream gets written to <code>destination</code>. The destination and source
streams are kept in sync by pausing and resuming as necessary.</p>

<p>用于将这个可读流和<code>destination</code>目标可写流连接起来，传入这个流中的数据将会写入到<code>destination</code>流中。通过在必要时暂停和恢复流，来源流和目的流得以保持同步。</p>

<p>Emulating the Unix <code>cat</code> command:</p>

<p>模拟Unix系统的<code>cat</code>命令：</p>

<pre><code>process.stdin.resume();
process.stdin.pipe(process.stdout);</code></pre>

<p>By default <code>end()</code> is called on the destination when the source stream emits
<code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end: false }</code> as
<code>options</code> to keep the destination stream open.</p>

<p>默认情况下，当来源流的<code>end</code>事件触发时目的流的<code>end()</code>方法会被调用，此时<code>destination</code>目的流将不再可写入。要在这种情况下为了保持目的流仍然可写入，可将<code>options</code>参数设为<code>{ end: false }</code>。</p>

<p>This keeps <code>process.stdout</code> open so that "Goodbye" can be written at the end.</p>

<p>这使<code>process.stdout</code>保持打开状态，因此"Goodbye"可以在end事件发生后被写入。</p>

<pre><code>process.stdin.resume();

process.stdin.pipe(process.stdout, { end: false });

process.stdin.on("end", function() {
  process.stdout.write("Goodbye\n");
});</code></pre>

<p>NOTE: If the source stream does not support <code>pause()</code> and <code>resume()</code>, this function
adds simple definitions which simply emit <code>'pause'</code> and <code>'resume'</code> events on
the source stream.</p>

<p>注意：如果来源流不支持<code>pause()</code>和<code>resume()</code>方法，此函数将在来源流对象上增加这两个方法的简单定义，内容为触发<code>'pause'</code>和<code>'resume'</code>事件。</p>

<h2 id="writable_Stream_">Writable Stream 可写流</h2>

<p>A <code>Writable Stream</code> has the following methods, members, and events.</p>

<p>一个<code>可写流</code>具有下列方法、成员、和事件。</p>

<h3 id="event_drain_drain_">Event: 'drain' 事件：'drain'</h3>

<p><code>function () { }</code></p>

<p>Emitted after a <code>write()</code> method was called that returned <code>false</code> to
indicate that it is safe to write again.</p>

<p>发生在<code>write()</code>方法被调用并返回<code>false</code>之后。此事件被触发说明内核缓冲区已空，再次写入是安全的。</p>

<h3 id="event_error_error_">Event: 'error' 事件：'error'</h3>

<p><code>function (exception) { }</code></p>

<p>Emitted on error with the exception <code>exception</code>.</p>

<p>发生错误时被触发，回调函数接收一个异常参数<code>exception</code>。</p>

<h3 id="event_close_close_">Event: 'close' 事件：'close'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the underlying file descriptor has been closed.</p>

<p>底层文件描述符被关闭时被触发。</p>

<h3 id="event_pipe_pipe_">Event: 'pipe' 事件：'pipe'</h3>

<p><code>function (src) { }</code></p>

<p>Emitted when the stream is passed to a readable stream's pipe method.</p>

<p>当此可写流作为参数传给一个可读流的pipe方法时被触发。</p>

<h3 id="stream.writable">stream.writable</h3>

<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occurred or <code>end()</code> / <code>destroy()</code> was called.</p>

<p>一个布尔值，默认值为<code>true</code>。在<code>'error'</code>事件被触发之后，或<code>end()</code> / <code>destroy()</code>方法被调用后此属性被设为<code>false</code>。</p>

<h3 id="stream.write">stream.write(string, encoding='utf8', [fd])</h3>

<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if
the string has been flushed to the kernel buffer.  Returns <code>false</code> to
indicate that the kernel buffer is full, and the data will be sent out in
the future. The <code>'drain'</code> event will indicate when the kernel buffer is
empty again. The <code>encoding</code> defaults to <code>'utf8'</code>.</p>

<p>使用指定编码<code>encoding</code>将字符串<code>string</code>写入到流中。如果字符串被成功写入内核缓冲区，此方法返回<code>true</code>。如果内核缓冲区已满，此方法返回<code>false</code>，数据将在以后被送出。当内核缓冲区再次被清空后'drain'<code>事件将被触发。</code>encoding<code>参数默认为</code>'utf8'`。</p>

<p>If the optional <code>fd</code> parameter is specified, it is interpreted as an integral
file descriptor to be sent over the stream. This is only supported for UNIX
streams, and is silently ignored otherwise. When writing a file descriptor in
this manner, closing the descriptor before the stream drains risks sending an
invalid (closed) FD.</p>

<p>如果指定了可选参数<code>fd</code>，它将被作为一个文件描述符通过流传送。此功能仅被Unix流所支持，对于其他流此操作将被忽略而没有任何提示。当使用此方法传送一个文件描述符时，如果在流没有清空前关闭此文件描述符，将造成传送一个无效（已关闭）FD的风险。</p>

<h3 id="stream.write">stream.write(buffer)</h3>

<p>Same as the above except with a raw buffer.</p>

<p>除了用一个Buffer对象替代字符串之外，其他同上。</p>

<h3 id="stream.end">stream.end()</h3>

<p>Terminates the stream with EOF or FIN.</p>

<p>使用EOF或FIN结束一个流的输出。</p>

<h3 id="stream.end">stream.end(string, encoding)</h3>

<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF
or FIN. This is useful to reduce the number of packets sent.</p>

<p>以指定的字符编码<code>encoding</code>传送一个字符串<code>string</code>，然后使用EOF或FIN结束流的输出。这对降低数据包传输量有所帮助。</p>

<h3 id="stream.end">stream.end(buffer)</h3>

<p>Same as above but with a <code>buffer</code>.</p>

<p>除了用一个<code>buffer</code>对象替代字符串之外，其他同上。</p>

<h3 id="stream.destroy">stream.destroy()</h3>

<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>

<p>关闭底层文件描述符。在此流上将不会再触发任何事件。</p>

<h2 id="crypto_">Crypto 加密模块</h2>

<p>Use <code>require('crypto')</code> to access this module.</p>

<p>使用<code>require('crypto')</code>调用加密模块。</p>

<p>The crypto module requires OpenSSL to be available on the underlying platform.
It offers a way of encapsulating secure credentials to be used as part
of a secure HTTPS net or http connection.</p>

<p>加密模块需要底层系统提供OpenSSL的支持。它提供了一种安全凭证的封装方式，可以用于HTTPS安全网络以及普通HTTP连接。</p>

<p>It also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.</p>

<p>该模块还提供了一套针对OpenSSL的hash（哈希），hmac（密钥哈希），cipher（编码），decipher（解码），sign（签名）以及verify（验证）等方法的封装。</p>

<h3 id="crypto.createCredentials">crypto.createCredentials(details)</h3>

<p>Creates a credentials object, with the optional details being a dictionary with keys:</p>

<p>创建一个凭证对象，可选参数details为一个带键值的字典：</p>

<ul><li><p><code>key</code> : a string holding the PEM encoded private key</p><p><code>key</code>：为字符串型，PEM编码的私钥。</p></li><li><p><code>cert</code> : a string holding the PEM encoded certificate</p><p><code>cert</code>：为字符串型，PEM编码的认证证书。</p></li><li><p><code>ca</code> : either a string or list of strings of PEM encoded CA certificates to trust.</p><p><code>ca</code>：字符串形式的PEM编码可信CA证书，或证书列表。</p></li></ul>

<p>If no 'ca' details are given, then node.js will use the default publicly trusted list of CAs as given in
<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>

<p>如果没有给出'ca'的详细内容，那么node.js将会使用默认的公开受信任列表，该表位于<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>。</p>

<h3 id="crypto.createHash">crypto.createHash(algorithm)</h3>

<p>Creates and returns a hash object, a cryptographic hash with the given algorithm
which can be used to generate hash digests.</p>

<p>创建并返回一个hash对象，它是一个指定算法的加密hash，用于生成hash摘要。</p>

<p><code>algorithm</code> is dependent on the available algorithms supported by the version
of OpenSSL on the platform. Examples are <code>'sha1'</code>, <code>'md5'</code>, <code>'sha256'</code>, <code>'sha512'</code>, etc.
On recent releases, <code>openssl list-message-digest-algorithms</code> will display the available digest algorithms.</p>

<p>参数<code>algorithm</code>可选择系统上安装的OpenSSL版本所支持的算法。例如：<code>'sha1'</code>, <code>'md5'</code>, <code>'sha256'</code>, <code>'sha512'</code>等。在近期发行的版本中，<code>openssl list-message-digest-algorithms</code>会显示这些可用的摘要算法。</p>

<h3 id="hash.update">hash.update(data)</h3>

<p>Updates the hash content with the given <code>data</code>.
This can be called many times with new data as it is streamed.</p>

<p>更新hash的内容为指定的<code>data</code>。当使用流数据时可能会多次调用该方法。</p>

<h3 id="hash.digest">hash.digest(encoding='binary')</h3>

<p>Calculates the digest of all of the passed data to be hashed.
The <code>encoding</code> can be <code>'hex'</code>, <code>'binary'</code> or <code>'base64'</code>.</p>

<p>计算所有传入数据的hash摘要。参数<code>encoding</code>（编码方式）可以为<code>'hex'</code>, <code>'binary'</code> 或者<code>'base64'</code>。</p>

<h3 id="crypto.createHmac">crypto.createHmac(algorithm, key)</h3>

<p>Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.</p>

<p>创建并返回一个hmac对象，它是一个指定算法和密钥的加密hmac。</p>

<p><code>algorithm</code> is dependent on the available algorithms supported by OpenSSL - see createHash above.
<code>key</code> is the hmac key to be used.</p>

<p>参数<code>algorithm</code>可选择OpenSSL支持的算法 - 参见上文的createHash。参数<code>key</code>为hmac所使用的密钥。</p>

<h3 id="hmac.update">hmac.update(data)</h3>

<p>Update the hmac content with the given <code>data</code>.
This can be called many times with new data as it is streamed.</p>

<p>更新hmac的内容为指定的<code>data</code>。当使用流数据时可能会多次调用该方法。</p>

<h3 id="hmac.digest">hmac.digest(encoding='binary')</h3>

<p>Calculates the digest of all of the passed data to the hmac.
The <code>encoding</code> can be <code>'hex'</code>, <code>'binary'</code> or <code>'base64'</code>.</p>

<p>计算所有传入数据的hmac摘要。参数<code>encoding</code>（编码方式）可以为<code>'hex'</code>, <code>'binary'</code> 或者<code>'base64'</code>。</p>

<h3 id="crypto.createCipher">crypto.createCipher(algorithm, key)</h3>

<p>Creates and returns a cipher object, with the given algorithm and key.</p>

<p>使用指定的算法和密钥创建并返回一个cipher对象。</p>

<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>'aes192'</code>, etc.
On recent releases, <code>openssl list-cipher-algorithms</code> will display the available cipher algorithms.</p>

<p>参数<code>algorithm</code>可选择OpenSSL支持的算法，例如<code>'aes192'</code>等。在最近的发行版中，<code>openssl list-cipher-algorithms</code>会显示可用的加密的算法。</p>

<h3 id="cipher.update">cipher.update(data, input_encoding='binary', output_encoding='binary')</h3>

<p>Updates the cipher with <code>data</code>, the encoding of which is given in <code>input_encoding</code>
and can be <code>'utf8'</code>, <code>'ascii'</code> or <code>'binary'</code>. The <code>output_encoding</code> specifies
the output format of the enciphered data, and can be <code>'binary'</code>, <code>'base64'</code> or <code>'hex'</code>.</p>

<p>使用参数<code>data</code>更新要加密的内容，其编码方式由参数<code>input_encoding</code>指定，可以为 <code>'utf8'</code>, <code>'ascii'</code>或者<code>'binary'</code>。参数<code>output_encoding</code>指定了已加密内容的输出编码方式，可以为 <code>'binary'</code>, <code>'base64'</code>或<code>'hex'</code>。</p>

<p>Returns the enciphered contents, and can be called many times with new data as it is streamed.</p>

<p>返回已加密的内容，当使用流数据时可能会多次调用该方法。</p>

<h3 id="cipher.final">cipher.final(output_encoding='binary')</h3>

<p>Returns any remaining enciphered contents, with <code>output_encoding</code> being one of: <code>'binary'</code>, <code>'ascii'</code> or <code>'utf8'</code>.</p>

<p>返回所有剩余的加密内容，<code>output_encoding</code>输出编码为<code>'binary'</code>, <code>'ascii'</code>或<code>'utf8'</code>其中之一。</p>

<h3 id="crypto.createDecipher">crypto.createDecipher(algorithm, key)</h3>

<p>Creates and returns a decipher object, with the given algorithm and key.
This is the mirror of the cipher object above.</p>

<p>使用给定的算法和密钥创建并返回一个解密对象。该对象为上述加密对象的反向运算。</p>

<h3 id="decipher.update">decipher.update(data, input_encoding='binary', output_encoding='binary')</h3>

<p>Updates the decipher with <code>data</code>, which is encoded in <code>'binary'</code>, <code>'base64'</code> or <code>'hex'</code>.
The <code>output_decoding</code> specifies in what format to return the deciphered plaintext: <code>'binary'</code>, <code>'ascii'</code> or <code>'utf8'</code>.</p>

<p>使用参数<code>data</code>更新要解密的内容，其编码方式为<code>'binary'</code>，<code>'base64'</code>或<code>'hex'</code>。参数<code>output_encoding</code>指定了已解密的明文内容的输出编码方式，可以为 <code>'binary'</code>，<code>'ascii'</code>或<code>'utf8'</code>。</p>

<h3 id="decipher.final">decipher.final(output_encoding='binary')</h3>

<p>Returns any remaining plaintext which is deciphered,
with <code>output_encoding' being one of: </code>'binary'<code>, </code>'ascii'<code> or </code>'utf8'`.</p>

<p>返回全部剩余的已解密的明文，其<code>output_encoding' 为</code>'binary'<code>, </code>'ascii'<code>或</code>'utf8'`其中之一。</p>

<h3 id="crypto.createSign">crypto.createSign(algorithm)</h3>

<p>Creates and returns a signing object, with the given algorithm.
On recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will display
the available signing algorithms. Examples are <code>'RSA-SHA256'</code>.</p>

<p>使用给定的算法创建并返回一个签名器对象。在现有的OpenSSL发行版中，<code>openssl list-public-key-algorithms</code>会显示可用的签名算法，例如：<code>'RSA-SHA256'</code>。</p>

<h3 id="signer.update">signer.update(data)</h3>

<p>Updates the signer object with data.
This can be called many times with new data as it is streamed.</p>

<p>使用data参数更新签名器对象。当使用流数据时可能会多次调用该方法。</p>

<h3 id="signer.sign">signer.sign(private_key, output_format='binary')</h3>

<p>Calculates the signature on all the updated data passed through the signer.
<code>private_key</code> is a string containing the PEM encoded private key for signing.</p>

<p>对所有传入签名器的数据计算其签名。<code>private_key</code>为字符串，它包含了PEM编码的用于签名的私钥。</p>

<p>Returns the signature in <code>output_format</code> which can be <code>'binary'</code>, <code>'hex'</code> or <code>'base64'</code>.</p>

<p>返回签名，其<code>output_format</code>输出可以为<code>'binary'</code>, <code>'hex'</code> 或者<code>'base64'</code>。</p>

<h3 id="crypto.createVerify">crypto.createVerify(algorithm)</h3>

<p>Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.</p>

<p>使用给定算法创建并返回一个验证器对象。它是上述签名器对象的反向运算。</p>

<h3 id="verifier.update">verifier.update(data)</h3>

<p>Updates the verifier object with data.
This can be called many times with new data as it is streamed.</p>

<p>使用data参数更新验证器对象。当使用流数据时可能会多次调用该方法。</p>

<h3 id="verifier.verify">verifier.verify(cert, signature, signature_format='binary')</h3>

<p>Verifies the signed data by using the <code>cert</code> which is a string containing
the PEM encoded public key, and <code>signature</code>, which is the previously calculates
signature for the data, in the <code>signature_format</code> which can be <code>'binary'</code>, <code>'hex'</code> or <code>'base64'</code>.</p>

<p>使用参数<code>cert</code>和<code>signature</code>验证已签名的数据，<code>cert</code>为经过PEM编码的公钥字符串，<code>signature</code>为之前已计算的数据的签名，<code>signature_format</code>可以为<code>'binary'</code>，<code>'hex'</code> 或者<code>'base64'</code>。</p>

<p>Returns true or false depending on the validity of the signature for the data and public key.</p>

<p>根据对数据和公钥进行签名有效性验证的结果，返回true或者false。
## TLS (SSL) TLS (SSL)模块</p>

<p>Use <code>require('tls')</code> to access this module.</p>

<p>使用<code>require('tls')</code>访问此模块。</p>

<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.</p>

<p><code>tls</code>模块使用OpenSSL提供Transport Layer Security（传输层安全协议）和 / 或Secure Socket Layer（安全套接层协议）：加密的通信流。</p>

<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this</p>

<p>TLS/SSL基于公钥/私钥的非对称加密体系，每一个客户端与服务器都需要拥有一个私有密钥。私有密钥可用如下方式生成：</p>

<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>

<p>All severs and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a "Certificate Signing Request" (CSR)
file. This is done with:</p>

<p>所有服务器和一部分客户端需要拥有一份数字证书。数字证书是由某个CA（数字证书认证机构）使用其公钥签名授予的，或者也可以用户自签名。要获得一份数字证书，首先需要生成一个CSR（证书签名请求）文件。方法如下：</p>

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>

<p>To create a self-signed certificate with the CSR, do this:</p>

<p>要使用CSR文件生成一个自签名的数字证书，方法如下：</p>

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>

<p>Alternatively you can send the CSR to a Certificate Authority for signing.</p>

<p>你也可以将CSR文件发给一家CA以获得签名。</p>

<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)</p>

<p>（关于如何创建CA的文档有待补充。感兴趣的用户可以直接浏览Node源代码中的<code>test/fixtures/keys/Makefile</code>文件）</p>

<h3 id="s_tls.connect">s = tls.connect(port, [host], [options], callback)</h3>

<p>Creates a new client connection to the given <code>port</code> and <code>host</code>. (If <code>host</code>
defaults to <code>localhost</code>.) <code>options</code> should be an object which specifies</p>

<p>建立一个到指定端口<code>port</code>和主机<code>host</code>的新的客户端连接。（<code>host</code>参数的默认值为<code>localhost</code>。）<code>options</code>是一个包含以下内容的对象：</p>

<ul><li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. (Required)</p><p><code>key</code>：包含服务器私钥的字符串或<code>Buffer</code>对象。密钥的格式为PEM。（必选）</p></li><li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in
PEM format.</p><p><code>cert</code>：包含服务器数字证书密钥的字符串或<code>Buffer</code>对象。密钥的格式为PEM。</p></li><li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known "root" CAs will be used, like VeriSign.
These are used to authorize connections.</p><p><code>ca</code>：包含可信任数字证书字符串或<code>Buffer</code>对象的数组。如果忽略此属性，则会使用几个常见的"根"CA的数字证书，如VeriSign。这些数字证书将被用来对连接进行验证。</p></li></ul>

<p><code>tls.connect()</code> returns a cleartext <code>CryptoStream</code> object.</p>

<p><code>tls.connect()</code>返回一个明文的<code>CryptoStream</code>对象。</p>

<p>After the TLS/SSL handshake the <code>callback</code> is called. The <code>callback</code> will be
called no matter if the server's certificate was authorized or not. It is up
to the user to test <code>s.authorized</code> to see if the server certificate was
signed by one of the specified CAs. If <code>s.authorized === false</code> then the error
can be found in <code>s.authorizationError</code>.</p>

<p>TLS/SSL连接握手之后<code>callback</code>回调函数会被调用。无论服务器的数字证书是否通过验证，<code>callback</code>函数都会被调用。用户应该检查<code>s.authorized</code>以确定服务器数字证书是否通过了验证（被某个可信任的CA签名）。当<code>s.authorized === false</code>时可以从<code>s.authorizationError</code>中获得具体的错误。</p>

<h3 id="tls.Server">tls.Server</h3>

<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.</p>

<p>这是<code>net.Server</code>的子类，拥有和<code>net.Server</code>完全一样的方法。区别在于这个类使用TLS或SSL建立加密的连接，而非仅仅接受原始的TCP连接。</p>

<p>Here is a simple example echo server:</p>

<p>下面是一个简单的回声服务器的例子：</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem')
};

tls.createServer(options, function (s) {
  s.write("welcome!\n");
  s.pipe(s);
}).listen(8000);</code></pre>

<p>You can test this server by connecting to it with <code>openssl s_client</code>:</p>

<p>你可以使用<code>openssl s_client</code>连接到这个服务器进行测试：</p>

<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>

<h4 id="tls.createServer">tls.createServer(options, secureConnectionListener)</h4>

<p>This is a constructor for the <code>tls.Server</code> class. The options object
has these possibilities:</p>

<p>这是<code>tls.Server</code>类的构造函数。参数options对象可以包含下列内容：</p>

<ul><li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. (Required)</p><p><code>key</code>：包含服务器私钥的字符串或<code>Buffer</code>对象。密钥的格式为PEM。（必选）</p></li><li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in
PEM format. (Required)</p><p><code>cert</code>：包含服务器数字证书密钥的字符串或<code>Buffer</code>对象。密钥的格式为PEM。（必选）</p></li><li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known "root" CAs will be used, like VeriSign.
These are used to authorize connections.</p><p><code>ca</code>：包含可信任数字证书字符串或<code>Buffer</code>对象的数组。如果忽略此属性，则会使用几个常见的"根"CA的数字证书，如VeriSign。这些证书将被用来对连接进行验证。</p></li><li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</p><p><code>requestCert</code>：如果设为<code>true</code>则服务器会向建立连接的客户端要求一个数字证书，并且试图去验证这份数字证书。默认为<code>false</code>。</p></li><li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p><p><code>rejectUnauthorized</code>：如果设为<code>true</code>则服务器将拒绝任何没有通过CA验证的连接。此选项仅在<code>requestCert</code>设为<code>true</code>时有效。默认为<code>false</code>。</p></li></ul>

<h4 id="event_secureConnection_secureConnection_">Event: 'secureConnection' 事件：'secureConnection'</h4>

<p><code>function (cleartextStream) {}</code></p>

<p>This event is emitted after a new connection has been successfully
handshaked. The argument is a duplex instance of <code>stream.Stream</code>. It has all
the common stream methods and events.</p>

<p>当一个新的连接成功完成握手过程后此事件被触发。参数是一个可读可写的<code>stream.Stream</code>实例对象，此对象具有Stream（流）对象所有公共的方法和事件。</p>

<p><code>cleartextStream.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code>cleartextStream.authorized</code> is false, then
<code>cleartextStream.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.</p>

<p><code>cleartextStream.authorized</code>是一个布尔值，用以表明客户端是否通过了服务器所指定的可信任CA的验证。如果<code>cleartextStream.authorized</code>值为false，则可以从<code>cleartextStream.authorizationError</code>中获得验证失败的原因。这意味着：未经验证的连接是有可能被接受的，这依赖于TLS服务器的具体设置。</p>

<h4 id="server.listen">server.listen(port, [host], [callback])</h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>

<p>开始在指定的端口<code>port</code>和主机名<code>host</code>上接受连接。如果没有设置<code>host</code>参数，服务器将接受到达本机所有IPv4地址（<code>INADDR_ANY</code>）的连接。</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<p>此函数是异步的。最后一个参数<code>callback</code>所指定的回调函数会在服务器绑定完成后被调用。</p>

<p>See <code>net.Server</code> for more information.</p>

<p>更多信息参见<code>net.Server</code>。</p>

<h4 id="server.close">server.close()</h4>

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>

<p>关闭服务器，停止接受新的连接请求。此函数是异步的，当服务器触发一个<code>'close'</code>事件时才真正被关闭。</p>

<h4 id="server.maxConnections">server.maxConnections</h4>

<p>Set this property to reject connections when the server's connection count gets high.</p>

<p>服务器最大连接数量。服务器会拒绝超过此数量限制的连接，以防止同时建立的连接数过多。</p>

<h4 id="server.connections">server.connections</h4>

<p>The number of concurrent connections on the server.</p>

<p>服务器并发连接数量。</p>

<h2 id="file_System_">File System 文件系统模块</h2>

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require('fs')</code>. All the methods have asynchronous and
synchronous forms.</p>

<p>文件的I/O是由标准POSIX函数封装而成。需要使用<code>require('fs')</code>访问这个模块。所有的方法都提供了异步和同步两种方式。 </p>

<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.</p>

<p>异步形式下，方法的最后一个参数需要传入一个执行完成时的回调函数。传给回调函数的参数取决于具体的异步方法，但第一个参数总是保留给异常对象。如果操作成功，那么该异常对象就变为<code>null</code>或者<code>undefined</code>。</p>

<p>Here is an example of the asynchronous version:</p>

<p>这里是一个异步调用的例子：</p>

<pre><code>var fs = require('fs');

fs.unlink('/tmp/hello', function (err) {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});</code></pre>

<p>Here is the synchronous version:</p>

<p>这里是进行相同操作的同步调用的例子：</p>

<pre><code>var fs = require('fs');

fs.unlinkSync('/tmp/hello')
console.log('successfully deleted /tmp/hello');</code></pre>

<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:</p>

<p>由于异步方法调用无法保证执行的顺序，所以下面的代码容易导致出现错误。</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  console.log('renamed complete');
});
fs.stat('/tmp/world', function (err, stats) {
  if (err) throw err;
  console.log('stats: ' + JSON.stringify(stats));
});</code></pre>

<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.</p>

<p>这样做有可能导致<code>fs.stat</code>在<code>fs.rename</code>之前执行，正确的做法是链式调用回调函数。</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  fs.stat('/tmp/world', function (err, stats) {
    if (err) throw err;
    console.log('stats: ' + JSON.stringify(stats));
  });
});</code></pre>

<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.</p>

<p>当需要频繁操作时，<em>强烈建议</em>使用异步方法。同步方式在其完成之前将会阻塞当前的整个进程，即搁置所有连接。 </p>

<h3 id="fs.rename">fs.rename(path1, path2, [callback])</h3>

<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步调用rename(2)，重命名某个文件，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.renameSync">fs.renameSync(path1, path2)</h3>

<p>Synchronous rename(2).</p>

<p>同步调用重命名rename(2)，重命名某个文件。</p>

<h3 id="fs.truncate">fs.truncate(fd, len, [callback])</h3>

<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.</p>

<p>异步调用ftruncate(2)，截断某个文件，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.truncateSync">fs.truncateSync(fd, len)</h3>

<p>Synchronous ftruncate(2).</p>

<p>同步调用重命名ftruncate(2)，截断某个文件s。</p>

<h3 id="fs.chmod">fs.chmod(path, mode, [callback])</h3>

<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步调用chmod(2)，修改文件权限，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.chmodSync">fs.chmodSync(path, mode)</h3>

<p>Synchronous chmod(2).</p>

<p>同步调用chmod(2)，修改文件权限。</p>

<h3 id="fs.stat">fs.stat(path, [callback])</h3>

<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. It looks like this:</p>

<p>异步调用stat(2)，读取文件元信息，回调函数将返回两个参数<code>(err, stats)</code>，其中<code>stats</code>是<code>fs.Stats</code>的一个对象，如下所示：</p>

<pre><code>{ dev: 2049,
  ino: 305352,
  mode: 16877,
  nlink: 12,
  uid: 1000,
  gid: 1000,
  rdev: 0,
  size: 4096,
  blksize: 4096,
  blocks: 8,
  atime: '2009-06-29T11:11:55Z',
  mtime: '2009-06-29T11:11:40Z',
  ctime: '2009-06-29T11:11:40Z' }</code></pre>

<p>See the <code>fs.Stats</code> section below for more information.</p>

<p>有关详细信息，请参阅下面的<code>fs.Stats</code>部分</p>

<h3 id="fs.lstat">fs.lstat(path, [callback])</h3>

<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. lstat() is identical to stat(), except that if
path is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.</p>

<p>异步形式调用lstat(2)，回调函数返回两个参数<code>(err, stats)</code>，其中<code>stats</code>是<code>fs.Stats</code>的一个对象，lstat()和stat()类似，区别在于当path是一个符号链接时，它指向该链接的属性，而不是所指向文件的属性.</p>

<h3 id="fs.fstat">fs.fstat(fd, [callback])</h3>

<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object.</p>

<p>异步形式调用fstat(2)，回调函数返回两个参数<code>(err, stats)</code>，其中<code>stats</code>是<code>fs.Stats</code>的一个对象。</p>

<h3 id="fs.statSync">fs.statSync(path)</h3>

<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.</p>

<p>同步形式调用stat(2)，返回<code>fs.Stats</code>的一个实例。</p>

<h3 id="fs.lstatSync">fs.lstatSync(path)</h3>

<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.</p>

<p>同步形式调用lstat(2)，返回<code>fs.Stats</code>的一个实例。</p>

<h3 id="fs.fstatSync">fs.fstatSync(fd)</h3>

<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.</p>

<p>同步形式调用fstatSync(2)，返回<code>fs.Stats</code>的一个实例。</p>

<h3 id="fs.link">fs.link(srcpath, dstpath, [callback])</h3>

<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.</p>

<p>异步调用link(2)，创建符号连接，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.linkSync">fs.linkSync(srcpath, dstpath)</h3>

<p>Synchronous link(2).</p>

<p>同步调用link(2)。</p>

<h3 id="fs.symlink">fs.symlink(linkdata, path, [callback])</h3>

<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步调用symlink(2)，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.symlinkSync">fs.symlinkSync(linkdata, path)</h3>

<p>Synchronous symlink(2).</p>

<p>同步调用symlink(2)。</p>

<h3 id="fs.readlink">fs.readlink(path, [callback])</h3>

<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
resolvedPath)</code>.</p>

<p>异步调用readlink，回调函数返回两个参数<code>(err,resolvedPath)</code>，<code>resolvedPath</code>为解析后的文件路径。</p>

<h3 id="fs.readlinkSync">fs.readlinkSync(path)</h3>

<p>Synchronous readlink(2). Returns the resolved path.</p>

<p>同步调用readlink(2)，返回解析后的文件路径。</p>

<h3 id="fs.realpath">fs.realpath(path, [callback])</h3>

<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err,
resolvedPath)</code>.</p>

<p>异步调用realpath(2)，回调函数返回两个参数<code>(err,resolvedPath)</code>，resolvedPath为解析后的文件路径。</p>

<h3 id="fs.realpathSync">fs.realpathSync(path)</h3>

<p>Synchronous realpath(2). Returns the resolved path.</p>

<p>同步调用realpath(2)，返回解析后的文件路径。</p>

<h3 id="fs.unlink">fs.unlink(path, [callback])</h3>

<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步调用unlink(2)，删除链接或者文件，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.unlinkSync">fs.unlinkSync(path)</h3>

<p>Synchronous unlink(2).</p>

<p>同步调用unlink(2)。</p>

<h3 id="fs.rmdir">fs.rmdir(path, [callback])</h3>

<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步调用rmdir(2)，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.rmdirSync">fs.rmdirSync(path)</h3>

<p>Synchronous rmdir(2).</p>

<p>同步调用rmdir(2)。</p>

<h3 id="fs.mkdir">fs.mkdir(path, mode, [callback])</h3>

<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步调用mkdir(2)，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.mkdirSync">fs.mkdirSync(path, mode)</h3>

<p>Synchronous mkdir(2).</p>

<p>同步调用mkdir(2)。</p>

<h3 id="fs.readdir">fs.readdir(path, [callback])</h3>

<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>'.'</code> and <code>'..'</code>.</p>

<p>异步调用readdir(3)，读取目录中的内容。回调函数接受两个参数<code>(err, files)</code>，其中<code>files</code>参数是保存了目录中所有文件名的数组（<code>'.'</code>和<code>'..'</code>除外）。</p>

<h3 id="fs.readdirSync">fs.readdirSync(path)</h3>

<p>Synchronous readdir(3). Returns an array of filenames excluding <code>'.'</code> and
<code>'..'</code>.</p>

<p>同步调用readdir(3)。返回目录中文件名数组(<code>'.'</code>与<code>'..'</code>除外)。 </p>

<h3 id="fs.close">fs.close(fd, [callback])</h3>

<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.</p>

<p>异步同步调用close(2)，关闭文件，除非回调函数执行过程出现了异常，否则不会传递任何参数。</p>

<h3 id="fs.closeSync">fs.closeSync(fd)</h3>

<p>Synchronous close(2).</p>

<p>同步调用close(2)。</p>

<h3 id="fs.open">fs.open(path, flags, mode=0666, [callback])</h3>

<p>Asynchronous file open. See open(2). Flags can be 'r', 'r+', 'w', 'w+', 'a',
or 'a+'. The callback gets two arguments <code>(err, fd)</code>.</p>

<p>异步开启文件，详阅open(2)。标签可为'r', 'r+', 'w', 'w+', 'a', 或 'a+'。回调函数接受两个参数<code>(err, fd)</code>。 </p>

<h3 id="fs.openSync">fs.openSync(path, flags, mode=0666)</h3>

<p>Synchronous open(2).</p>

<p>同步调用open(2)。</p>

<h3 id="fs.utimes">fs.utimes(path, atime, mtime, callback)</h3>

<h3 id="fs.utimesSync">fs.utimesSync(path, atime, mtime)</h3>

<p>Change file timestamps.</p>

<p>更改文件时间戳。</p>

<h3 id="fs.futimes">fs.futimes(path, atime, mtime, callback)</h3>

<h3 id="fs.futimesSync">fs.futimesSync(path, atime, mtime)</h3>

<p>Change file timestamps with the difference that if filename refers to a
symbolic link, then the link is not dereferenced.</p>

<p>另一种更改文件时间戳的方式。区别在于如果文件名指向一个符号链接，则改变此符号链接的时间戳，而不改变所引用文件的时间戳。</p>

<h3 id="fs.write">fs.write(fd, buffer, offset, length, position, [callback])</h3>

<p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>

<p>将<code>buffer</code>缓冲器内容写入<code>fd</code>文件描述符。</p>

<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.</p>

<p><code>offset</code>和<code>length</code>决定了将缓冲器中的哪部分写入文件。</p>

<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>position</code> is <code>null</code>, the data will be written at the
current position.
See pwrite(2).</p>

<p><code>position</code>指明将数据写入文件从头部算起的偏移位置，若<code>position</code>为<code>null</code>，数据将从当前位置开始写入，详阅pwrite(2)。</p>

<p>The callback will be given two arguments <code>(err, written)</code> where <code>written</code>
specifies how many <em>bytes</em> were written.</p>

<p>回调函数接受两个参数<code>(err, written)</code>，其中<code>written</code>标识有多少<em>字节</em>的数据已经写入。</p>

<h3 id="fs.writeSync">fs.writeSync(fd, buffer, offset, length, position)</h3>

<p>Synchronous version of buffer-based <code>fs.write()</code>. Returns the number of bytes
written.</p>

<p>基于缓冲器的<code>fs.write()</code>的同步版本，返回写入数据的字节数。</p>

<h3 id="fs.writeSync">fs.writeSync(fd, str, position, encoding='utf8')</h3>

<p>Synchronous version of string-based <code>fs.write()</code>. Returns the number of bytes
written.</p>

<p>基于字符串的<code>fs.write()</code>的同步版本，返回写入数据的字节数。</p>

<h3 id="fs.read">fs.read(fd, buffer, offset, length, position, [callback])</h3>

<p>Read data from the file specified by <code>fd</code>.</p>

<p>从<code>fd</code>文件描述符中读取数据。</p>

<p><code>buffer</code> is the buffer that the data will be written to.</p>

<p><code>buffer</code>为写入数据的缓冲器。</p>

<p><code>offset</code> is offset within the buffer where writing will start.</p>

<p><code>offset</code>为写入到缓冲器的偏移地址。</p>

<p><code>length</code> is an integer specifying the number of bytes to read.</p>

<p><code>length</code>指明了欲读取的数据字节数。</p>

<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.</p>

<p><code>position</code>为一个整形变量，标识从哪个位置开始读取文件，如果<code>position</code>参数为<code>null</code>，数据将从文件当前位置开始读取。</p>

<p>The callback is given the two arguments, <code>(err, bytesRead)</code>.</p>

<p>回调函数接受两个参数，<code>(err, bytesRead)</code>。</p>

<h3 id="fs.readSync">fs.readSync(fd, buffer, offset, length, position)</h3>

<p>Synchronous version of buffer-based <code>fs.read</code>. Returns the number of
<code>bytesRead</code>.</p>

<p>基于缓冲器的<code>fs.read</code>的同步版本，返回读取到的<code>bytesRead</code>字节数。</p>

<h3 id="fs.readSync">fs.readSync(fd, length, position, encoding)</h3>

<p>Synchronous version of string-based <code>fs.read</code>. Returns the number of
<code>bytesRead</code>.</p>

<p>基于字符串的<code>fs.read</code>的同步版本，返回已经读入的数据的字节数。</p>

<h3 id="fs.readFile">fs.readFile(filename, [encoding], [callback])</h3>

<p>Asynchronously reads the entire contents of a file. Example:</p>

<p>异步读取一个文件的所有内容，例子如下：</p>

<pre><code>fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>

<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.</p>

<p>回调函数将传入两个参数<code>(err, data)</code>，其中<code>data</code>为文件内容。</p>

<p>If no encoding is specified, then the raw buffer is returned.</p>

<p>如果没有设置编码，那么将返回原始内容格式的缓冲器。</p>

<h3 id="fs.readFileSync">fs.readFileSync(filename, [encoding])</h3>

<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.</p>

<p>同步调用<code>fs.readFile</code>的版本，返回指定文件<code>filename</code>的文件内容。</p>

<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it
returns a buffer.</p>

<p>如果设置了<code>encoding</code>参数，将返回一个字符串。否则返回一个缓冲器。</p>

<h3 id="fs.writeFile">fs.writeFile(filename, data, encoding='utf8', [callback])</h3>

<p>Asynchronously writes data to a file. <code>data</code> can be a string or a buffer.</p>

<p>异步写入数据到某个文件中，<code>data</code>可以是字符串或者缓冲器。</p>

<p>Example:</p>

<p>例子：</p>

<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {
  if (err) throw err;
  console.log('It\'s saved!');
});</code></pre>

<h3 id="fs.writeFileSync">fs.writeFileSync(filename, data, encoding='utf8')</h3>

<p>The synchronous version of <code>fs.writeFile</code>.</p>

<p>同步调用<code>fs.writeFile</code>的方式。</p>

<h3 id="fs.watchFile">fs.watchFile(filename, [options], listener)</h3>

<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file is accessed.</p>

<p>监听指定文件<code>filename</code>的变化，回调函数<code>listener</code>将在每次该文件被访问时被调用。</p>

<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>, a polling
value in milliseconds. The default is <code>{ persistent: true, interval: 0 }</code>.</p>

<p>第二个参数是可选项，如果指定了<code>options</code>参数，它应该是一个包含如下内容的对象：名为<code>persistent</code>的布尔值，和名为<code>interval</code>单位为毫秒的轮询时间间隔，默认值为<code>{ persistent: true, interval: 0 }</code>。</p>

<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:</p>

<p><code>listener</code>监听器将获得两个参数，分别标识当前的状态对象和改变前的状态对象。</p>

<pre><code>fs.watchFile(f, function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});</code></pre>

<p>These stat objects are instances of <code>fs.Stat</code>.</p>

<p>这些状态对象为<code>fs.Stat</code>的实例。</p>

<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code>curr.mtime</code> and `prev.mtime.</p>

<p>如果你想在文件被修改而不是被访问时得到通知，你还需要比较<code>curr.mtime</code>和<code>prev.mtime</code>的值。</p>

<h3 id="fs.unwatchFile">fs.unwatchFile(filename)</h3>

<p>Stop watching for changes on <code>filename</code>.</p>

<p>停止监听文件<code>filename</code>的变化。</p>

<h2 id="fs.Stats">fs.Stats</h2>

<p>Objects returned from <code>fs.stat()</code> and <code>fs.lstat()</code> are of this type.</p>

<p><code>fs.stat()</code>和 <code>fs.lstat()</code>方法返回的对象为此类型。</p>

<ul><li><code>stats.isFile()</code></li><li><code>stats.isDirectory()</code></li><li><code>stats.isBlockDevice()</code></li><li><code>stats.isCharacterDevice()</code></li><li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)
<code>stats.isSymbolicLink()</code> （仅对<code>fs.lstat()</code>有效）</li><li><code>stats.isFIFO()</code></li><li><code>stats.isSocket()</code></li></ul>

<h2 id="fs.ReadStream">fs.ReadStream</h2>

<p><code>ReadStream</code> is a <code>Readable Stream</code>.</p>

<p><code>ReadStream</code>是一个<code>Readable Stream</code>可读流。</p>

<h3 id="fs.createReadStream">fs.createReadStream(path, [options])</h3>

<p>Returns a new ReadStream object (See <code>Readable Stream</code>).</p>

<p>返回一个新的可读流对象（参见<code>Readable Stream</code>）。</p>

<p><code>options</code> is an object with the following defaults:</p>

<p><code>options</code>是包含如下默认值的对象：</p>

<pre><code>{ flags: 'r',
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}</code></pre>

<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0.  When used, both the limits must be specified always.</p>

<p>如果不想读取文件的全部内容，可以在<code>options</code>参数中设置<code>start</code>和<code>end</code>属性值以读取文件中指定范围的内容。<code>start</code>和<code>end</code>包含在范围中（闭集合），取值从0开始。这两个参数需要同时设置。</p>

<p>An example to read the last 10 bytes of a file which is 100 bytes long:</p>

<p>一个例子演示了从一个长度为100字节的文件中读取最后10个字节：</p>

<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});</code></pre>

<h2 id="fs.WriteStream">fs.WriteStream</h2>

<p><code>WriteStream</code> is a <code>Writable Stream</code>.</p>

<p><code>WriteStream</code>为可写流。</p>

<h3 id="event_open_open_">Event: 'open' 事件：'open'</h3>

<p><code>function (fd) { }</code></p>

<p> <code>fd</code> is the file descriptor used by the WriteStream.</p>

<p> <code>fd</code>是可写流所使用的文件描述符。</p>

<h3 id="fs.createWriteStream">fs.createWriteStream(path, [options])</h3>

<p>Returns a new WriteStream object (See <code>Writable Stream</code>).</p>

<p>返回一个新的可写流对象（参见<code>Writable Stream</code>）。</p>

<p><code>options</code> is an object with the following defaults:</p>

<p><code>options</code>参数是包含如下默认值的对象：</p>

<pre><code>{ flags: 'w',
  encoding: null,
  mode: 0666 }</code></pre>

<h2 id="path_">Path 路径模块</h2>

<p>This module contains utilities for dealing with file paths.  Use
<code>require('path')</code> to use it.  It provides the following methods:</p>

<p>该模块包括了一些处理文件路径的功能，可以通过<code>require('path')</code>方法来使用它。该模块提供了如下的方法：</p>

<h3 id="path.normalize">path.normalize(p)</h3>

<p>Normalize a string path, taking care of <code>'..'</code> and <code>'.'</code> parts.</p>

<p>该方法用于标准化一个字符型的路径，请注意<code>'..'</code> 与 <code>'.'</code> 的使用。</p>

<p>When multiple slashes are found, they're replaces by a single one;
when the path contains a trailing slash, it is preserved.
On windows backslashes are used. </p>

<p>当发现有多个斜杠（/）时，系统会将他们替换为一个斜杠；如果路径末尾中包含有一个斜杠，那么系统会保留这个斜杠。在Windows中，上述路径中的斜杠（/）要换成反斜杠（\）。</p>

<p>Example:</p>

<p>示例：</p>

<pre><code>path.normalize('/foo/bar//baz/asdf/quux/..')
// returns
'/foo/bar/baz/asdf'</code></pre>

<h3 id="path.join">path.join([path1], [path2], [...])</h3>

<p>Join all arguments together and normalize the resulting path.</p>

<p>该方法用于合并方法中的各参数并得到一个标准化合并的路径字符串。</p>

<p>Example:</p>

<p>示例：</p>

<pre><code>node&gt; require('path').join(
...   '/foo', 'bar', 'baz/asdf', 'quux', '..')
'/foo/bar/baz/asdf'</code></pre>

<h3 id="path.resolve">path.resolve([from ...], to)</h3>

<p>Resolves <code>to</code> to an absolute path.</p>

<p>将<code>to</code>参数解析为绝对路径。</p>

<p>If <code>to</code> isn't already absolute <code>from</code> arguments are prepended in right to left
order, until an absolute path is found. If after using all <code>from</code> paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path 
gets resolved to the root directory.</p>

<p>如果参数 <code>to</code>当前不是绝对的，系统会将<code>from</code> 参数按从右到左的顺序依次前缀到<code>to</code>上，直到在<code>from</code>中找到一个绝对路径时停止。如果遍历所有<code>from</code>中的路径后，系统依然没有找到一个绝对路径，那么当前工作目录也会作为参数使用。最终得到的路径是标准化的字符串，并且标准化时系统会自动删除路径末尾的斜杠，但是如果获取的路径是解析到根目录的，那么系统将保留路径末尾的斜杠。</p>

<p>Another way to think of it is as a sequence of <code>cd</code> commands in a shell.</p>

<p>你也可以将这个方法理解为Shell中的一组<code>cd</code>命令。</p>

<pre><code>path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')</code></pre>

<p>Is similar to:</p>

<p>就类似于：</p>

<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>

<p>The difference is that the different paths don't need to exist and may also be
files.</p>

<p>该方法与<code>cd</code>命令的区别在于该方法中不同的路径不一定存在，而且这些路径也可能是文件。</p>

<p>Examples:</p>

<p>示例：</p>

<pre><code>path.resolve('/foo/bar', './baz')
// returns
'/foo/bar/baz'

path.resolve('/foo/bar', '/tmp/file/')
// returns
'/tmp/file'

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
// if currently in /home/myself/node, it returns
'/home/myself/node/wwwroot/static_files/gif/image.gif'</code></pre>

<h3 id="path.dirname">path.dirname(p)</h3>

<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.</p>

<p>该方法返回一个路径的目录名，类似于Unix中的<code>dirname</code>命令。</p>

<p>Example:</p>

<p>示例：</p>

<pre><code>path.dirname('/foo/bar/baz/asdf/quux')
// returns
'/foo/bar/baz/asdf'</code></pre>

<h3 id="path.basename">path.basename(p, [ext])</h3>

<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.</p>

<p>该方法返回一个路径中最低一级目录名，类似于Unix中的 <code>basename</code>命令。</p>

<p>Example:</p>

<p>示例：</p>

<pre><code>path.basename('/foo/bar/baz/asdf/quux.html')
// returns
'quux.html'

path.basename('/foo/bar/baz/asdf/quux.html', '.html')
// returns
'quux'</code></pre>

<h3 id="path.extname">path.extname(p)</h3>

<p>Return the extension of the path.  Everything after the last '.' in the last portion
of the path.  If there is no '.' in the last portion of the path or the only '.' is
the first character, then it returns an empty string.  </p>

<p>该方法返回路径中的文件扩展名，即路径最低一级的目录中'.'字符后的任何字符串。如果路径最低一级的目录中'没有'.' 或者只有'.'，那么该方法返回一个空字符串。</p>

<p>Examples:</p>

<p>示例：</p>

<pre><code>path.extname('index.html')
// returns
'.html'

path.extname('index')
// returns
''</code></pre>

<h3 id="path.exists">path.exists(p, [callback])</h3>

<p>Test whether or not the given path exists.  Then, call the <code>callback</code> argument
with either true or false. Example:</p>

<p>该方法用于测试参数<code>p</code>中的路径是否存在。然后以true或者false作为参数调用<code>callback</code>回调函数。示例：</p>

<pre><code>path.exists('/etc/passwd', function (exists) {
  util.debug(exists ? "it's there" : "no passwd!");
});</code></pre>

<h3 id="path.existsSync">path.existsSync(p)</h3>

<p>Synchronous version of <code>path.exists</code>.</p>

<p><code>path.exists</code>的同步版本。
## net 网络模块</p>

<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with <code>require("net");</code></p>

<p><code>net</code>模块为你提供了一种异步网络包装器，它包含创建服务器和客户端（称为streams）所需的方法，您可以通过调用<code>require("net")</code>来使用此模块。</p>

<h3 id="net.createServer">net.createServer([options], [connectionListener])</h3>

<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <code>'connection'</code> event.</p>

<p>创建一个新的TCP服务器，参数<code>connectionListener</code>被自动设置为connection事件的监听器。</p>

<p><code>options</code> is an object with the following defaults:</p>

<p><code>options</code>参数为一个对象，默认值如下：
    { allowHalfOpen: false
    }</p>

<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won't automatically send FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the end() method explicitly.
See <code>'end'</code> event for more information.</p>

<p>如果<code>allowHalfOpen</code>参数为<code>true</code>，则当客户端socket发送FIN包时，服务器端socket不会自动发送FIN包。此情况下服务器端socket将变为不可读状态，但仍然可写。你需要明确的调用end()方法来关闭连接。更多内容请参照<code>'end'</code>事件。</p>

<h3 id="net.createConnection">net.createConnection(arguments...)</h3>

<p>Construct a new socket object and opens a socket to the given location. When
the socket is established the <code>'connect'</code> event will be emitted.</p>

<p>创建一个新的socket对象，并建立到指定地址的socket连接。当socket建立后，<code>'connect'</code>事件将被触发。</p>

<p>The arguments for this method change the type of connection:</p>

<p>不同的参数决定了连接的类型：</p>

<ul><li><p><code>net.createConnection(port, [host])</code></p><p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted, <code>localhost</code>
will be assumed.</p><p>创建一个到主机<code>host</code>的<code>port</code>端口的TCP连接，如果略了<code>host</code>参数，默认连接到<code>localhost</code>。</p></li><li><p><code>net.createConnection(path)</code></p><p>Creates unix socket connection to <code>path</code></p><p>创建连接到<code>path</code>路径的unix socket。</p></li></ul>

<hr />

<h3 id="net.Server">net.Server</h3>

<p>This class is used to create a TCP or UNIX server.</p>

<p>这个类用于创建一个TCP或UNIX服务器。</p>

<p>Here is an example of a echo server which listens for connections
on port 8124:</p>

<p>下面的例子创建了一个在8124端口监听的<code>echo</code>服务器。</p>

<pre><code>var net = require('net');
var server = net.createServer(function (c) {
  c.write('hello\r\n');
  c.pipe(c);
});
server.listen(8124, 'localhost');</code></pre>

<p>Test this by using <code>telnet</code>:</p>

<p>使用<code>telnet</code>测试该服务器。</p>

<pre><code>telnet localhost 8124</code></pre>

<p>To listen on the socket <code>/tmp/echo.sock</code> the last line would just be
changed to</p>

<p>如要监听socket <code>/tmp/echo.sock</code>，最后一行代码需要修改成：</p>

<pre><code>server.listen('/tmp/echo.sock');</code></pre>

<p>Use <code>nc</code> to connect to a UNIX domain socket server:</p>

<p>使用<code>nc</code>命令连接到一个UNIX域socket服务器：</p>

<pre><code>nc -U /tmp/echo.sock</code></pre>

<p><code>net.Server</code> is an <code>EventEmitter</code> with the following events:</p>

<p><code>net.Server</code>是下列事件的 <code>EventEmitter</code>（事件触发器）:</p>

<h4 id="server.listen">server.listen(port, [host], [callback])</h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>

<p>开始接收特定主机<code>host</code>的<code>port</code>端口的连接，如果省略了<code>host</code>参数，服务器将接收任何指向IPV4地址的连接。</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<p>此函数是异步的，在服务器被绑定时，最后一个参数<code>callback</code>回调函数将被调用。</p>

<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. Meaning
another server is already running on the requested port. One way of handling this
would be to wait a second and the try again. This can be done with</p>

<p>一些用户可能会遇到<code>EADDRINUSE</code> 错误，该错误消息的意思是已经有另一个服务运行在请求的端口上，一个解决方法就是等一会再试一下，就像下面的代码这样：</p>

<pre><code>server.on('error', function (e) {
  if (e.code == 'EADDRINUSE') {
    console.log('Address in use, retrying...');
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>

<p>(Note: All sockets in Node are set SO_REUSEADDR already)</p>

<p>（注意：Node中所有的socket都已经设置成SO_REUSEADDR端口重用模式）</p>

<h4 id="server.listen">server.listen(path, [callback])</h4>

<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>

<p>启动一个UNIX socket服务，监听指定的<code>path</code>路径上的连接。</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<p>此函数是异步的，在服务器被绑定时，最后一个参数<code>callback</code>回调函数将被调用。</p>

<h4 id="server.listenFD">server.listenFD(fd)</h4>

<p>Start a server listening for connections on the given file descriptor.</p>

<p>启动一个服务，监听指定的文件描述符上的连接。</p>

<p>This file descriptor must have already had the <code>bind(2)</code> and <code>listen(2)</code> system
calls invoked on it.</p>

<p>此文件描述符上必须已经执行了 <code>bind(2)</code> 和<code>listen(2)</code> 系统调用。</p>

<h4 id="server.close">server.close()</h4>

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>

<p>关闭服务，停止接收新的连接。该函数是异步的，当服务发出<code>'close'</code>事件时该服务器被最终关闭。</p>

<h4 id="server.address">server.address()</h4>

<p>Returns the bound address of the server as seen by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address</p>

<p>返回绑定到操作系统的服务器地址。如果绑定地址是由操作系统自动分配的，可用此方法查看具体的端口号。</p>

<p>Example:</p>

<pre><code>var server = net.createServer(function (socket) {
  socket.end("goodbye\n");
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log("opened server on %j", address);
});</code></pre>

<h4 id="server.maxConnections">server.maxConnections</h4>

<p>Set this property to reject connections when the server's connection count gets high.</p>

<p>设置该属性的值，以便当服务器达到最大连接数时不再接受新的连接。</p>

<h4 id="server.connections">server.connections</h4>

<p>The number of concurrent connections on the server.</p>

<p>服务器的并发连接数。</p>

<h4 id="event_connection_connection_">Event: 'connection' 事件：'connection'</h4>

<p><code>function (socket) {}</code></p>

<p>Emitted when a new connection is made. <code>socket</code> is an instance of
<code>net.Socket</code>.</p>

<p>当一个新的连接建立时触发。<code>socket</code> 是<code>net.Socket</code>的一个实例。</p>

<h4 id="event_close_">Event: 'close'</h4>

<p><code>function () {}</code></p>

<p>Emitted when the server closes.</p>

<p>当服务器关闭时触发。</p>

<hr />

<h3 id="net.Socket">net.Socket</h3>

<p>This object is an abstraction of of a TCP or UNIX socket.  <code>net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>'connection'</code> event of a server.</p>

<p>这是TCP或UNIX socket的抽象对象。<code>net.Socket</code>实例实现了一个全双工的流接口。此实例可以是由用户建立用作客户端（使用<code>connect()</code>方法），也可能由Node建立并通过服务器的<code>'connection'</code>事件传给用户。</p>

<p><code>net.Socket</code> instances are EventEmitters with the following events:</p>

<p><code>net.Socket</code> 的实例是下列事件的事件触发器:</p>

<h4 id="new_net.Socket">new net.Socket([options])</h4>

<p>Construct a new socket object.</p>

<p>构造一个新的socket对象。</p>

<p><code>options</code> is an object with the following defaults:</p>

<p><code>options</code>参数是一个对象，默认值如下：</p>

<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>

<p><code>fd</code> allows you to specify the existing file descriptor of socket. <code>type</code>
specified underlying protocol. It can be <code>'tcp4'</code>, <code>'tcp6'</code>, or <code>'unix'</code>.
About <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>'end'</code> event.</p>

<p><code>fd</code>参数允许你指定一个已经存在的socket的文件描述符。<code>type</code>参数用于指定底层协议，可选值包括<code>'tcp4'</code>，<code>'tcp6'</code>或<code>'unix'</code>。关于<code>allowHalfOpen</code>，可参考<code>createServer()</code>和<code>'end'</code>事件。</p>

<h4 id="socket.connect">socket.connect(port, [host], [callback])</h4>

<h4 id="socket.connect">socket.connect(path, [callback])</h4>

<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,
then the socket will be opened as a TCP socket, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be
opened as a unix socket to that path.</p>

<p>打开一下指定socket的连接。如果给出了<code>port</code> 和 <code>host</code>，将作为一个TCP socket打开，如果省略了<code>host</code>，将默认连接到<code>localhost</code>。如果指定了<code>path</code>，该socket将作为一个UNIX socket打开，并连接到<code>path</code>路径。</p>

<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket or if a
Socket is closed and you want to reuse it to connect to another server.</p>

<p>通常情况下该方法并不需要，使用 <code>net.createConnection</code> 就可以打开socket。只有在你实现一个自定义的socket，或者你想重用一个已经关闭的socket连接到另一个服务器。</p>

<p>This function is asynchronous. When the <code>'connect'</code> event is emitted the
socket is established. If there is a problem connecting, the <code>'connect'</code>
event will not be emitted, the <code>'error'</code> event will be emitted with
the exception.</p>

<p>这个函数是异步函数。当发生 <code>'connect'</code>事件时socket被建立，如果连接遇到问题， <code>'connect'</code>事件不会被触发，而携带异常信息的<code>'error'</code> 事件将被触发。</p>

<p>The <code>callback</code> parameter will be added as an listener for the 'connect'
event.</p>

<p>参数<code>callback</code>将作为 <code>connect</code>事件的监听器被增加进来。</p>

<h4 id="socket.bufferSize">socket.bufferSize</h4>

<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to
help users get up an running quickly. The computer cannot necessarily keep up
with the amount of data that is written to a socket - the network connection simply
might be too slow. Node will internally queue up the data written to a socket and
send it out over the wire when it is possible. (Internally it is polling on
the socket's file descriptor for being writable).</p>

<p><code>net.Socket</code>有一个特性，那就是<code>socket.write()</code>随时可用，这是为了使程序更快的运行。计算机发送数据的速度可能无法跟上程序向socket写入数据的速度——考虑网络速度很慢的情况。Node在内部维护了一个队列用于保存写入socket的数据，并在网络允许的时候将队列中的数据发送出去。（内部实现是探测socket的文件描述符是否可写。）</p>

<p>The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)</p>

<p>这种内部缓冲区的机制会增加内存消耗。此属性显示当前被缓冲的待写入字符数量。（字符的数量约等于字节数，但缓冲区中可能包含字符串，而字符串是延迟编码的，因此精确的字节数不可知。）</p>

<p>Users who experience large or growing <code>bufferSize</code> should attempt to
"throttle" the data flows in their program with <code>pause()</code> and <code>resume()</code>.</p>

<p>用户可以在程序中使用<code>pause()</code>和<code>resume()</code>来"截流"数据流，以控制大量或不断增长的<code>bufferSize</code>。</p>

<h4 id="socket.setEncoding">socket.setEncoding(encoding=null)</h4>

<p>Sets the encoding (either <code>'ascii'</code>, <code>'utf8'</code>, or <code>'base64'</code>) for data that is
received.</p>

<p>设置接收到的数据的编码(可以是<code>'ascii'</code>，<code>'utf8'</code>或<code>'base64'</code>) 。</p>

<h4 id="socket.setSecure">socket.setSecure()</h4>

<p>This function has been removed in v0.3. It used to upgrade the connection to
SSL/TLS. See the TLS for the new API.</p>

<p>该函数用来将连接升级到SSL/TLS，在v0.3版本已经被废弃。参考TLS中新的API说明。</p>

<h4 id="socket.write">socket.write(data, [encoding], [callback])</h4>

<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.</p>

<p>向socket发送数据，第二个参数指定在发送字符串数据时的编码方式，默认的是UTF8编码。</p>

<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>'drain'</code> will be emitted when the buffer is again free.</p>

<p>在所有数据被成功的写入系统内核缓冲区时返回<code>true</code>，如果全部或部分数据进入了用户内存的队列则返回<code>false</code>。
当缓冲区再次变空时，<code>'drain'</code> 事件将被触发。</p>

<p>The optional <code>callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.</p>

<p>可选参数<code>callback</code> 将在数据最终被写出时执行——可能不是立即执行。</p>

<h4 id="socket.write">socket.write(data, [encoding], [fileDescriptor], [callback])</h4>

<p>For UNIX sockets, it is possible to send a file descriptor through the
socket. Simply add the <code>fileDescriptor</code> argument and listen for the <code>'fd'</code>
event on the other end.</p>

<p>对于UNIX socket，可以通过socket发送一个文件描述符，简单的增加参数 <code>fileDescriptor</code>，并在另一端监听<code>'fd'</code>事件。</p>

<h4 id="socket.end">socket.end([data], [encoding])</h4>

<p>Half-closes the socket. I.E., it sends a FIN packet. It is possible the
server will still send some data.</p>

<p>发送一个FIN数据包，关闭socket半连接。服务器仍可能发送一些数据。</p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>socket.write(data, encoding)</code>
followed by <code>socket.end()</code>.</p>

<p>如果指定了<code>data</code> ，等同于依次调用<code>socket.write(data, encoding)</code>和<code>socket.end()</code>。</p>

<h4 id="socket.destroy">socket.destroy()</h4>

<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).</p>

<p>确保该socket上不再有活动的I/O操作，仅在发生错误的情况下需要（如解析错误等）。</p>

<h4 id="socket.pause">socket.pause()</h4>

<p>Pauses the reading of data. That is, <code>'data'</code> events will not be emitted.
Useful to throttle back an upload.</p>

<p>暂停读取数据，<code>'data'</code>将不会被触发，便于控制上传速度。</p>

<h4 id="socket.resume">socket.resume()</h4>

<p>Resumes reading after a call to <code>pause()</code>.</p>

<p>用于在调用<code>pause()</code>后，恢复读取数据。</p>

<h4 id="socket.setTimeout">socket.setTimeout(timeout, [callback])</h4>

<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on
the socket. By default <code>net.Socket</code> do not have a timeout.</p>

<p>设置socket不活动时间超过<code>timeout</code> 毫秒后进入超时状态。默认情况下<code>net.Socket</code>不会超时。</p>

<p>When an idle timeout is triggered the socket will receive a <code>'timeout'</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the socket.</p>

<p>当闲置超时发生时，socket会接收到一个<code>'timeout'</code>事件，但是连接不会被断开，用户必须手动的<code>end()</code>或<code>destroy()</code>该socket。</p>

<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>

<p>如果 <code>timeout</code>设置成0，已经存在的闲置超时将被禁用。</p>

<p>The optional <code>callback</code> parameter will be added as a one time listener for the <code>'timeout'</code> event.</p>

<p>可选参数<code>callback</code> 将作为一次性监听器添加到 <code>'timeout'</code> 事件。</p>

<h4 id="socket.setNoDelay">socket.setNoDelay(noDelay=true)</h4>

<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>noDelay</code> will
immediately fire off data each time <code>socket.write()</code> is called.</p>

<p>禁用Nagle算法。默认情况下TCP连接使用Nagle算法，在发送数据之前缓存它们。设置<code>noDelay</code>将使每次<code>socket.write()</code>调用都实时发送数据。</p>

<h4 id="socket.setKeepAlive">socket.setKeepAlive(enable=false, [initialDelay])</h4>

<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting.</p>

<p>开启或禁用keep-alive（连接保持）功能。可选择设置在一个闲置socket上第一次发送存活探测之前的延迟时间。设置<code>initialDelay</code>（单位毫秒）以设置最后从一个数据包接收到第一个存活探测发送之间的延时。将initialDelay设为0将不改变此参数默认（或之前）的设置。</p>

<h4 id="socket.remoteAddress">socket.remoteAddress</h4>

<p>The string representation of the remote IP address. For example,
<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<p>以字符串形式表示的远端设备IP地址。例如：<code>'74.125.127.100'</code>或<code>'2001:4860:a005::68'</code>。</p>

<p>This member is only present in server-side connections.</p>

<p>此成员只存在于服务器端连接中。</p>

<h4 id="event_connect_connect_">Event: 'connect' 事件：'connect'</h4>

<p><code>function () { }</code></p>

<p>Emitted when a socket connection successfully is established.
See <code>connect()</code>.</p>

<p>当一个socket连接成功建立时触发，参考 <code>connect()</code>。</p>

<h4 id="event_data_data_">Event: 'data' 事件：'data'</h4>

<p><code>function (data) { }</code></p>

<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.
(See the section on <code>Readable Socket</code> for more information.)</p>

<p>当收到数据时触发，参数<code>data</code>将是一个缓冲区（<code>Buffer</code>）或者字符串（<code>String</code>）。数据的编码方式通过<code>socket.setEncoding()</code>设置。（ 更多信息请参考章节<code>Readable Socket</code>）</p>

<h4 id="event_end_end_">Event: 'end' 事件：'end'</h4>

<p><code>function () { }</code></p>

<p>Emitted when the other end of the socket sends a FIN packet.</p>

<p>当socket的远端发送了一个FIN数据包时触发。</p>

<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code>end()</code> their side now.</p>

<p>默认情况下（<code>allowHalfOpen == false</code>）一旦待写出队列中的内容全部被写出，socket将自动销毁它的文件描述符。然而如果设置<code>allowHalfOpen == true</code>，则socket不会自动调用<code>end()</code>，而是允许用户继续写入任意数量的数据，这种情况下需要用户主动调用<code>end()</code>关闭半连接。</p>

<h4 id="event_timeout_timeout_">Event: 'timeout' 事件：'timeout'</h4>

<p><code>function () { }</code></p>

<p>Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.</p>

<p>当socket闲置超时情况下触发，它只是用来通知那个socket已经空闲，用户必须手动的关闭该连接。</p>

<p>See also: <code>socket.setTimeout()</code></p>

<p>参考: <code>socket.setTimeout()</code></p>

<h4 id="event_drain_drain_">Event: 'drain' 事件：'drain'</h4>

<p><code>function () { }</code></p>

<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>

<p>当缓冲区变空时触发，可以被用来调节上传速度。</p>

<h4 id="event_error_error_">Event: 'error' 事件：'error'</h4>

<p><code>function (exception) { }</code></p>

<p>Emitted when an error occurs.  The <code>'close'</code> event will be called directly
following this event.</p>

<p>当有错误发生时触发， <code>'close'</code> 事件紧跟其后被调用。</p>

<h4 id="event_close_close_">Event: 'close' 事件：'close'</h4>

<p><code>function (had_error) { }</code></p>

<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean
which says if the socket was closed due to a transmission error.</p>

<p>当连接字完全被关闭时触发，参数<code>had_error</code>是一个布尔型变量， 用来说明连接字是否由于一个传输错误而关闭。</p>

<hr />

<h3 id="net.isIP">net.isIP</h3>

<h4 id="net.isIP">net.isIP(input)</h4>

<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.</p>

<p>测试输入参数是否是一个IP地址，如果是一个无效的字符串，返回0；如果是IPv4地址，返回4；如果是IPv6地址，返回6。</p>

<h4 id="net.isIPv4">net.isIPv4(input)</h4>

<p>Returns true if input is a version 4 IP address, otherwise returns false.</p>

<p>如果input是一个IPv4地址则返回true，否则返回false。</p>

<h4 id="net.isIPv6">net.isIPv6(input)</h4>

<p>Returns true if input is a version 6 IP address, otherwise returns false.</p>

<p>如果input是一个IPv6地址则返回true，否则返回false。</p>

<h2 id="dNS_DNS_">DNS DNS模块</h2>

<p>Use <code>require('dns')</code> to access this module.</p>

<p>使用<code>require('dns')</code>来访问这个模块。 </p>

<p>Here is an example which resolves <code>'www.google.com'</code> then reverse
resolves the IP addresses which are returned.</p>

<p>下面这个例子首先将<code>'www.google.com'</code>解析为IP地址，再对返回的IP地址做反向解析。</p>

<pre><code>var dns = require('dns');

dns.resolve4('www.google.com', function (err, addresses) {
  if (err) throw err;

  console.log('addresses: ' + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        console.log('reverse for ' + a + ' failed: ' +
          err.message);
      } else {
        console.log('reverse for ' + a + ': ' +
          JSON.stringify(domains));
      }
    });
  });
});</code></pre>

<h3 id="dns.lookup">dns.lookup(domain, family=null, callback)</h3>

<p>Resolves a domain (e.g. <code>'google.com'</code>) into the first found A (IPv4) or
AAAA (IPv6) record.</p>

<p>将一个域名(例如<code>'google.com'</code>)解析成为找到的第一个A(IPv4)或者AAAA(IPv6)记录。</p>

<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
necessarily the value initially passed to <code>lookup</code>).</p>

<p>回调函数有<code>(err, address, family)</code>这三个参数。<code>address</code>参数是一个代表IPv4或IPv6地址的字符串。<code>family</code>是一个表示地址版本的整数4或6(并不一定和调用<code>lookup</code>时传入的<code>family</code>参数值相同)。</p>

<h3 id="dns.resolve">dns.resolve(domain, rrtype='A', callback)</h3>

<p>Resolves a domain (e.g. <code>'google.com'</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>A</code> (IPV4 addresses), <code>AAAA</code> (IPV6
addresses), <code>MX</code> (mail exchange records), <code>TXT</code> (text records), <code>SRV</code> (SRV
records), and <code>PTR</code> (used for reverse IP lookups).</p>

<p>将域名(比如<code>'google.com'</code>)按照参数rrtype所指定类型的解析结果放到一个数组中。合法的类型为<code>A</code>（IPV4地址），<code>AAAA</code>（IPV6地址），<code>MX</code>（邮件交换记录），<code>TXT</code>（文本记录），SRV（SRV记录），和PTR（用于反向IP解析）。 </p>

<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.</p>

<p>回调函数接受两个参数：<code>(err, addresses)</code>。参数<code>address</code>中的每一项的类型根据所要求的记录类型进行判断，在下面相应的解析方法的文档里有详细的解释。 </p>

<p>On error, <code>err</code> would be an instanceof <code>Error</code> object, where <code>err.errno</code> is
one of the error codes listed below and <code>err.message</code> is a string describing
the error in English.</p>

<p>当有错误发生时，参数<code>err</code>的内容是一个<code>Error</code>对象的实例，<code>err.errno</code>属性是下面错误代码列表中的一个，<code>err.message</code>属性是一个用英语表述的错误解释。 </p>

<h3 id="dns.resolve4">dns.resolve4(domain, callback)</h3>

<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).
<code>addresses</code> is an array of IPv4 addresses (e.g.
<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>).</p>

<p>与<code>dns.resolve()</code>类似，但是仅对IPV4地址进行查询（<code>A</code>记录）。<code>addresses</code>是一个IPV4地址数组（例如<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>）。</p>

<h3 id="dns.resolve6">dns.resolve6(domain, callback)</h3>

<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).</p>

<p>除了这个函数是对IPV6地址的查询（一个<code>AAAA</code>查询）外与<code>dns.resolve4()</code>很类似。 </p>

<h3 id="dns.resolveMx">dns.resolveMx(domain, callback)</h3>

<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).</p>

<p>与<code>dns.resolve()</code>很类似，但是仅做邮件交换地址查询（<code>MX</code>类型记录）。 </p>

<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>).</p>

<p>回调函数的参数<code>addresses</code>是一个MX类型记录的数组，每个记录有一个优先级属性和一个交换属性（类似<code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>）。 </p>

<h3 id="dns.resolveTxt">dns.resolveTxt(domain, callback)</h3>

<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>['v=spf1 ip4:0.0.0.0 ~all']</code>).</p>

<p>与<code>dns.resolve()</code>很相似，但是仅可以进行文本查询（<code>TXT</code>记录）。<code>addressed</code>是一个对于<code>domain</code>域有效的文本记录数组（类似<code>['v=spf1 ip4:0.0.0.0 ~all']</code>）。</p>

<h3 id="dns.resolveSrv">dns.resolveSrv(domain, callback)</h3>

<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>).</p>

<p>与<code>dns.resolve()</code>很类似，但仅是只查询服务记录（<code>SRV</code>类型记录）。<code>addresses</code>是一个对于域来说有效的SRV记录的数组，SRV记录的属性有优先级、权重、端口，名字（例如<code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>）。</p>

<h3 id="dns.reverse">dns.reverse(ip, callback)</h3>

<p>Reverse resolves an ip address to an array of domain names.</p>

<p>反向解析一个IP地址到一个域名数组。</p>

<p>The callback has arguments <code>(err, domains)</code>.</p>

<p>回调函数的参数为 <code>(err, domains)</code>。</p>

<p>If there an an error, <code>err</code> will be non-null and an instanceof the Error
object.</p>

<p>如果发生了错误，<code>err</code>将被置为一个非空的Error对象实例。 </p>

<p>Each DNS query can return an error code.</p>

<p>每个DNS查询可以返回如下错误代码：</p>

<ul><li><p><code>dns.TEMPFAIL</code>: timeout, SERVFAIL or similar.</p><p><code>dns.TEMPFAIL</code>: 超时，SERVFAIL或者类似的错误。</p></li><li><p><code>dns.PROTOCOL</code>: got garbled reply.</p><p><code>dns.PROTOCOL</code>: 返回内容混乱。</p></li><li><p><code>dns.NXDOMAIN</code>: domain does not exists.</p><p><code>dns.NXDOMAIN</code>: 域名不存在。</p></li><li><p><code>dns.NODATA</code>: domain exists but no data of reqd type.</p><p><code>dns.NODATA</code>: 域名存在但是没有所请求的查询类型的数据。 </p></li><li><p><code>dns.NOMEM</code>: out of memory while processing.</p><p><code>dns.NOMEM</code>: 处理过程中内存溢出。</p></li><li><p><code>dns.BADQUERY</code>: the query is malformed.</p><p><code>dns.BADQUERY</code>: 查询语句语法错误。
## UDP / Datagram Sockets 数据报套接字模块</p></li></ul>

<p>Datagram sockets are available through <code>require('dgram')</code>.  Datagrams are most commonly
handled as IP/UDP messages but they can also be used over Unix domain sockets.</p>

<p>要使用数据报套接字模块需要调用<code>require('dgram')</code>。数据报通常作为IP/UDP消息来处理，但它也可用于Unix域套接字。 </p>

<h3 id="event_message_message_">Event: 'message' 事件：'message'</h3>

<p><code>function (msg, rinfo) { }</code></p>

<p>Emitted when a new datagram is available on a socket.  <code>msg</code> is a <code>Buffer</code> and <code>rinfo</code> is
an object with the sender's address information and the number of bytes in the datagram.</p>

<p>当套接字接收到一个新的数据报的时候触发此事件。<code>msg</code>是一个<code>Buffer</code>缓冲器，<code>rinfo</code>是一个包含了发送方地址信息以及数据报字节长度的对象。</p>

<h3 id="event_listening_listening_">Event: 'listening' 事件：'listening'</h3>

<p><code>function () { }</code></p>

<p>Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.  Unix domain sockets do not start listening until calling <code>bind()</code> on them.</p>

<p>当一个套接字开始监听数据报的时候触发。一旦UDP套接字建立后就会触发这个事件。而Unix域套接字直到调用了<code>bind()</code>方法才会开始监听。</p>

<h3 id="event_close_close_">Event: 'close' 事件：'close'</h3>

<p><code>function () { }</code></p>

<p>Emitted when a socket is closed with <code>close()</code>.  No new <code>message</code> events will be emitted
on this socket.</p>

<p>当调用<code>close()</code>方法关闭一个套接字时触发此事件。此后不会再有新的<code>message</code>事件在此套接字上发生。</p>

<h3 id="dgram.createSocket">dgram.createSocket(type, [callback])</h3>

<p>Creates a datagram socket of the specified types.  Valid types are:
<code>udp4</code>, <code>udp6</code>, and <code>unix_dgram</code>.</p>

<p>建立一个指定类型的数据报套接字，有效类型有：<code>udp4</code>，<code>udp6</code>，以及<code>unix_dgram</code>。 </p>

<p>Takes an optional callback which is added as a listener for <code>message</code> events.</p>

<p>可选参数callback指定了<code>message</code>事件的监听器回调函数。 </p>

<h3 id="dgram.send">dgram.send(buf, offset, length, path, [callback])</h3>

<p>For Unix domain datagram sockets, the destination address is a pathname in the filesystem.
An optional callback may be supplied that is invoked after the <code>sendto</code> call is completed
by the OS.  It is not safe to re-use <code>buf</code> until the callback is invoked.  Note that
unless the socket is bound to a pathname with <code>bind()</code> there is no way to receive messages
on this socket.</p>

<p>对于Unix域数据报套接字而言，目标地址是文件系统中的一个路径。可选参数callback指定了系统调用<code>sendto</code>完成后的回调函数。在回调函数callback执行前重复使用buf是很不安全的。要注意除非这个套接字已经使用<code>bind()</code>方法绑定到一个路径上，否则这个套接字无法接收到任何信息。 </p>

<p>Example of sending a message to syslogd on OSX via Unix domain socket <code>/var/run/syslog</code>:</p>

<p>一个在OSX系统上，通过Unix域套接字<code>/var/run/syslog</code>向syslogd发送消息的例子：</p>

<pre><code>var dgram = require('dgram');
var message = new Buffer("A message to log.");
var client = dgram.createSocket("unix_dgram");
client.send(message, 0, message.length, "/var/run/syslog",
  function (err, bytes) {
    if (err) {
      throw err;
    }
    console.log("Wrote " + bytes + " bytes to socket.");
});</code></pre>

<h3 id="dgram.send">dgram.send(buf, offset, length, port, address, [callback])</h3>

<p>For UDP sockets, the destination port and IP address must be specified.  A string
may be supplied for the <code>address</code> parameter, and it will be resolved with DNS.  An
optional callback may be specified to detect any DNS errors and when <code>buf</code> may be
re-used.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick.  The only way to know for sure that a send has taken place
is to use the callback.</p>

<p>对于UDP套接字来说，目标端口和IP地址是必须要指定的。可以用字符串来指定<code>address</code>参数，这个参数通过DNS进行解析。可选参数callback指定一个回调函数，用于检测DNS解析错误以及什么时候<code>buf</code>可被重用。注意DNS查询将会使发送动作最少延迟到下一个时间片执行，如果你想确定发送动作是否发生，使用回调将是唯一的办法。</p>

<p>Example of sending a UDP packet to a random port on <code>localhost</code>;</p>

<p>下面是一个发送UDP数据包到<code>localhost</code>（本机）一个随机端口的例子：</p>

<pre><code>var dgram = require('dgram');
var message = new Buffer("Some bytes");
var client = dgram.createSocket("udp4");
client.send(message, 0, message.length, 41234, "localhost");
client.close();</code></pre>

<h3 id="dgram.bind">dgram.bind(path)</h3>

<p>For Unix domain datagram sockets, start listening for incoming datagrams on a
socket specified by <code>path</code>. Note that clients may <code>send()</code> without <code>bind()</code>,
but no datagrams will be received without a <code>bind()</code>.</p>

<p>对Unix域数据报套接字来说，通过指定一个<code>path</code>（路径）开始在套接字上监听数据报。注意客户端可以无需调用<code>bind()</code>直接使用<code>send()</code>方法发送数据报，但是不使用<code>bind()</code>方法将无法接收到任何数据报。 </p>

<p>Example of a Unix domain datagram server that echoes back all messages it receives:</p>

<p>下面是一个Unix域数据报服务器的例子，此服务器将接收到的所有消息原样返回： </p>

<pre><code>var dgram = require("dgram");
var serverPath = "/tmp/dgram_server_sock";
var server = dgram.createSocket("unix_dgram");

server.on("message", function (msg, rinfo) {
  console.log("got: " + msg + " from " + rinfo.address);
  server.send(msg, 0, msg.length, rinfo.address);
});

server.on("listening", function () {
  console.log("server listening " + server.address().address);
})

server.bind(serverPath);</code></pre>

<p>Example of a Unix domain datagram client that talks to this server:</p>

<p>下面是一个与上述服务器通信的Unix域数据报客户端的例子： </p>

<pre><code>var dgram = require("dgram");
var serverPath = "/tmp/dgram_server_sock";
var clientPath = "/tmp/dgram_client_sock";

var message = new Buffer("A message at " + (new Date()));

var client = dgram.createSocket("unix_dgram");

client.on("message", function (msg, rinfo) {
  console.log("got: " + msg + " from " + rinfo.address);
});

client.on("listening", function () {
  console.log("client listening " + client.address().address);
  client.send(message, 0, message.length, serverPath);
});

client.bind(clientPath);</code></pre>

<h3 id="dgram.bind">dgram.bind(port, [address])</h3>

<p>For UDP sockets, listen for datagrams on a named <code>port</code> and optional <code>address</code>.  If
<code>address</code> is not specified, the OS will try to listen on all addresses.</p>

<p>对于UDP套接字而言，该方法会在<code>port</code>指定的端口和可选地址 <code>address</code>上监听数据报。如果<code>address</code>没有指定，则操作系统会监听所有有效地址。 </p>

<p>Example of a UDP server listening on port 41234:</p>

<p>下面是一个监听在41234端口的UDP服务器的例子：</p>

<pre><code>var dgram = require("dgram");

var server = dgram.createSocket("udp4");
var messageToSend = new Buffer("A message to send");

server.on("message", function (msg, rinfo) {
  console.log("server got: " + msg + " from " +
    rinfo.address + ":" + rinfo.port);
});

server.on("listening", function () {
  var address = server.address();
  console.log("server listening " +
      address.address + ":" + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>

<h3 id="dgram.close">dgram.close()</h3>

<p>Close the underlying socket and stop listening for data on it.  UDP sockets
automatically listen for messages, even if they did not call <code>bind()</code>.</p>

<p>该函数关闭底层的套接字并停止在其上监听数据。UDP套接字在没有调用<code>bing()</code>方法的情况下也自动监听消息。</p>

<h3 id="dgram.address">dgram.address()</h3>

<p>Returns an object containing the address information for a socket.  For UDP sockets,
this object will contain <code>address</code> and <code>port</code>.  For Unix domain sockets, it will contain
only <code>address</code>.</p>

<p>返回包含套接字地址信息的对象。对于UDP套接字来说，这个对象将包含<code>address</code>（地址）和<code>port</code>（端口）。对于UNIX域套接字来说，这个对象仅包含<code>address</code>（地址）。</p>

<h3 id="dgram.setBroadcast">dgram.setBroadcast(flag)</h3>

<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When this option is set, UDP packets
may be sent to a local interface's broadcast address.</p>

<p>设置或者清除套接字的<code>SO_BROADCAST</code>（广播）选项。当该设置生效时，UDP数据包将被发送至本地网络接口的广播地址。</p>

<h3 id="dgram.setTTL">dgram.setTTL(ttl)</h3>

<p>Sets the <code>IP_TTL</code> socket option.  TTL stands for "Time to Live," but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network
probes or when multicasting.</p>

<p>设置套接字的<code>IP_TTL</code>选项，TTL表示“存活时间”，但是在这个上下文环境中，特指一个数据包允许经过的IP跳数。每经过一个路由器或者网关TTL的值都会减一，如果TTL被一个路由器减少到0，这个数据包将不会继续转发。在网络探针或组播应用中会需要修改TTL数值。</p>

<p>The argument to <code>setTTL()</code> is a number of hops between 1 and 255.  The default on most
systems is 64.</p>

<p>在<code>setTTL()</code>调用中设置的跳数介于1到255之间，大多数系统缺省会设置为64。 </p>

<h3 id="dgram.setMulticastTTL">dgram.setMulticastTTL(ttl)</h3>

<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  TTL stands for "Time to Live," but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic.  Each router or gateway that forwards a packet
decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.</p>

<p>设置套接字的<code>IP_MULTICAST_TTL</code>选项。TTL全称"Time to Live"，原指存活时间，但在这里特指在组播通信中数据包允许经过的IP跳数。每经过一个路由器或者网关TTL的值都会减一。如果TTL被一个路由器减少到0，那么该数据包将不会继续传播。</p>

<p>The argument to <code>setMulticastTTL()</code> is a number of hops between 0 and 255.  The default on most
systems is 64.</p>

<p><code>setMulticastTTL()</code>的参数为1至255之间的跳数，大部分操作系统的默认值为64。</p>

<h3 id="dgram.setMulticastLoopback">dgram.setMulticastLoopback(flag)</h3>

<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When this option is set, multicast
packets will also be received on the local interface.</p>

<p>设置或清除套接字的<code>IP_MULTICAST_LOOP</code>选项。当该选项生效时，多路传播的数据包也会被本地网络接口接收到。</p>

<h3 id="dgram.addMembership">dgram.addMembership(multicastAddress, [multicastInterface])</h3>

<p>Tells the kernel to join a multicast group with <code>IP_ADD_MEMBERSHIP</code> socket option.</p>

<p>该方法通知系统内核使用<code>IP_ADD_MEMBERSHIP</code>套接字选项将套接字加入一个组播组。</p>

<p>If <code>multicastAddress</code> is not specified, the OS will try to add membership to all valid
interfaces.</p>

<p>如果没有指定<code>multicastInterface</code>参数，操作系统将尝试把所有有效的网络接口加入组播组。</p>

<h3 id="dgram.dropMembership">dgram.dropMembership(multicastAddress, [multicastInterface])</h3>

<p>Opposite of <code>addMembership</code> - tells the kernel to leave a multicast group with
<code>IP_DROP_MEMBERSHIP</code> socket option. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this.</p>

<p>与<code>addMembership</code>相反，该方法通知系统内核使用<code>IP_DROP_MEMBERSHIP</code>选项使套接字脱离组播组。由于当套接字关闭或进程终止时该操作会自动执行，所以大部分的应用不需要手动调用该方法。</p>

<p>If <code>multicastAddress</code> is not specified, the OS will try to drop membership to all valid
interfaces.</p>

<p>如果<code>multicastInterface</code>没有指定，操作系统会尝试将所有可用网络接口从组播组里脱离。</p>

<h2 id="hTTP_HTTP_">HTTP HTTP模块</h2>

<p>To use the HTTP server and client one must <code>require('http')</code>.</p>

<p>如果要使用HTTP的服务器以及客户端，需使用<code>require('http')</code>加载HTTP模块。 </p>

<p>The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.</p>

<p>Node中的HTTP接口在设计时就考虑到了要支持HTTP协议的很多特性，并且使用简单。特别是可以处理那些内容庞大，有可能是块编码的消息。该接口被设计为从不缓冲整个请求或相应，这样用户就可以以流的方式处理数据。 </p>

<p>HTTP message headers are represented by an object like this:</p>

<p>HTTP头信息以如下对象形式表示：</p>

<pre><code>{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'accept': '*/*' }</code></pre>

<p>Keys are lowercased. Values are not modified.</p>

<p>所有键名被转为小写，而值不会被修改。</p>

<p>In order to support the full spectrum of possible HTTP applications, Node's
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.</p>

<p>为了支持尽可能多的HTTP应用，Node提供非常底层的HTTP API。它只处理流相关的操作以及进行信息解析。API将信息解析为头部和正文，但并不解析实际的头部和正文内的具体内容。</p>

<h2 id="http.Server">http.Server</h2>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<p>这是一个带有如下事件的<code>EventEmitter</code>事件触发器：</p>

<h3 id="event_request_request_">Event: 'request' 事件：'request'</h3>

<p><code>function (request, response) { }</code></p>

<p> <code>request</code> is an instance of <code>http.ServerRequest</code> and <code>response</code> is
 an instance of <code>http.ServerResponse</code></p>

<p> <code>request</code>是<code>http.ServerRequest</code>的一个实例，而<code>response</code>是<code>http.ServerResponse</code>的一个实例。</p>

<h3 id="event_connection_connection_">Event: 'connection' 事件：'connection'</h3>

<p><code>function (stream) { }</code></p>

<p> When a new TCP stream is established. <code>stream</code> is an object of type
 <code>net.Stream</code>. Usually users will not want to access this event. The
 <code>stream</code> can also be accessed at <code>request.connection</code>.</p>

<p> 当一个新的TCP流建立后触发此事件。<code>stream</code>是一个<code>net.Stream</code>类型的对象，通常用户不会使用这个事件。参数<code>stream</code>也可以在<code>request.connection</code>中获得。</p>

<h3 id="event_close_close_">Event: 'close' 事件：'close'</h3>

<p><code>function (errno) { }</code></p>

<p> Emitted when the server closes.</p>

<p> 当服务器关闭的时候触发此事件。 </p>

<h3 id="event_request_request_">Event: 'request' 事件：'request'</h3>

<p><code>function (request, response) {}</code></p>

<p>Emitted each time there is request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).</p>

<p>每个请求发生的时候均会被触发。请注意每个连接可能会有多个请求（在keep-alive连接情况下）。</p>

<h3 id="event_checkContinue_checkContinue_">Event: 'checkContinue' 事件：'checkContinue'</h3>

<p><code>function (request, response) {}</code></p>

<p>Emitted each time a request with an http Expect: 100-continue is received.
If this event isn't listened for, the server will automatically respond
with a 100 Continue as appropriate.</p>

<p>每当带有Exception: 100-continue头的请求被接收到时触发此事件。如果该事件未被监听，服务器会视情况自动的使用100 Continue应答。</p>

<p>Handling this event involves calling <code>response.writeContinue</code> if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.</p>

<p>该事件的处理涉及两种情况，如果客户端应当继续发送请求正文，那么需要调用<code>response.writeContinue</code>，而如果客户端不应该继续发送请求正文，那么应该产生一个适当的HTTP回应（如400错误请求）。</p>

<p>Note that when this event is emitted and handled, the <code>request</code> event will
not be emitted.</p>

<p>注意如果该事件被触发并处理的话，那么将不再触发<code>request</code>事件。</p>

<h3 id="event_upgrade_upgrade_">Event: 'upgrade' 事件：'upgrade'</h3>

<p><code>function (request, socket, head)</code></p>

<p>Emitted each time a client requests a http upgrade. If this event isn't
listened for, then clients requesting an upgrade will have their connections
closed.</p>

<p>每当一个客户端请求http upgrade时触发此消息。如果这个事件没有监听，那么请求upgrade的客户端的连接将被关闭。 </p>

<ul><li><p><code>request</code> is the arguments for the http request, as it is in the request event.
<code>request</code>代表一个http请求的相关参数，和它在request事件中的意思相同。</p></li><li><p><code>socket</code> is the network socket between the server and client.
<code>socket</code>是在服务器与客户端之间连接使用的网络套接字。 </p></li><li><p><code>head</code> is an instance of Buffer, the first packet of the upgraded stream, this may be empty.
<code>head</code>是一个缓冲器实例，是upgraded流的第一个包，这个缓冲器可以是空的。 </p></li></ul>

<p>After this event is emitted, the request's socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.</p>

<p>当此事件被触发后，该请求所使用的套接字将不会有一个<code>data</code>事件监听器。这意味着你如果需要处理通过这个套接字发送到服务器端的数据则需要自己绑定<code>data</code>事件监听器。 </p>

<h3 id="event_clientError_clientError_">Event: 'clientError' 事件：'clientError'</h3>

<p><code>function (exception) {}</code></p>

<p>If a client connection emits an 'error' event - it will forwarded here.</p>

<p>当客户端连接出现错误时会触发'error'事件。</p>

<h3 id="http.createServer">http.createServer(requestListener)</h3>

<p>Returns a new web server object.</p>

<p>返回一个新的web server对象。 </p>

<p>The <code>requestListener</code> is a function which is automatically
added to the <code>'request'</code> event.</p>

<p>requestListener监听器会自动添加到<code>'request'</code>事件中。</p>

<h3 id="server.listen">server.listen(port, [hostname], [callback])</h3>

<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>

<p>在指定端口和主机名上接受连接。如果hostname没有指定，服务器将直接在此机器的所有IPV4地址上接受连接(<code>INADDR_ANY</code>)。 </p>

<p>To listen to a unix socket, supply a filename instead of port and hostname.</p>

<p>如果要在UNIX套接字上监听的话，则需要提供一个文件名来替换端口和主机名。 </p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound to the port.</p>

<p>这个方法是一个异步的方法，当服务器已经在此端口上完成绑定后讲调用<code>callback</code>回调函数。 </p>

<h3 id="server.listen">server.listen(path, [callback])</h3>

<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>

<p>建立一个UNIX套接字服务器并在指定<code>path</code>路径上监听。 </p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<p>这个方法是一个异步的方法，当服务器完成绑定后将调用<code>callback</code>回调函数。</p>

<h3 id="server.close">server.close()</h3>

<p>Stops the server from accepting new connections.</p>

<p>使此服务器停止接受任何新连接。</p>

<h2 id="http.ServerRequest">http.ServerRequest</h2>

<p>This object is created internally by a HTTP server -- not by
the user -- and passed as the first argument to a <code>'request'</code> listener.</p>

<p>这个对象通常由HTTP服务器（而非用户）自动建立，并作为第一个参数传给<code>'request'</code>监听器。</p>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<p>这是一个带有如下事件的<code>EventEmitter</code>事件触发器： </p>

<h3 id="event_data_data_">Event: 'data' 事件：'data'</h3>

<p><code>function (chunk) { }</code></p>

<p>Emitted when a piece of the message body is received.</p>

<p>当接收到信息正文中的一部分时候会触发此事件。 </p>

<p>Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk is a string.  The body encoding is set with
<code>request.setBodyEncoding()</code>.</p>

<p>例如：正文的数据块将作为唯一的参数传递给回调函数。此时传输编码已被解码。正文数据块是一个字符串，正文的编码由<code>request.setBodyEncoding()</code>方法设定。 </p>

<h3 id="event_end_end_">Event: 'end' 事件：'end'</h3>

<p><code>function () { }</code></p>

<p>Emitted exactly once for each message. No arguments.  After
emitted no other events will be emitted on the request.</p>

<p>每次完全接收完信息后都会触发一次，不接受任何参数。当这个事件被触发后，将不会再触发其他事件。 </p>

<h3 id="request.method">request.method</h3>

<p>The request method as a string. Read only. Example:
<code>'GET'</code>, <code>'DELETE'</code>.</p>

<p>表示请求方式的只读字符串。例如<code>'GET'</code>，<code>'DELETE'</code>。 </p>

<h3 id="request.url">request.url</h3>

<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:</p>

<p>代表所请求URL的字符串。他仅包括实际的HTTP请求中的URL地址。如果这个请求是： </p>

<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>

<p>Then <code>request.url</code> will be:</p>

<p>则<code>request.url</code>应当是：</p>

<pre><code>'/status?name=ryan'</code></pre>

<p>If you would like to parse the URL into its parts, you can use
<code>require('url').parse(request.url)</code>.  Example:</p>

<p>如果你想要解析这个URL中的各个部分，可以使用<code>require('url').parse(request.url)</code>。例如： </p>

<pre><code>node&gt; require('url').parse('/status?name=ryan')
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status' }</code></pre>

<p>If you would like to extract the params from the query string,
you can use the <code>require('querystring').parse</code> function, or pass
<code>true</code> as the second argument to <code>require('url').parse</code>.  Example:</p>

<p>如果你想从查询字符串中提取所有参数，你可以使用<code>require('querystring').parse</code>方法，或者传一个<code>true</code>作为第二个参数给<code>require('url').parse</code>方法。例如：</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan', true)
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: { name: 'ryan' },
  pathname: '/status' }</code></pre>

<h3 id="request.headers">request.headers</h3>

<p>Read only.</p>

<p>只读。</p>

<h3 id="request.trailers">request.trailers</h3>

<p>Read only; HTTP trailers (if present). Only populated after the 'end' event.</p>

<p>只读，HTTP尾部（如果存在的话），只有在'end'事件被触发后该值才会被填充。</p>

<h3 id="request.httpVersion">request.httpVersion</h3>

<p>The HTTP protocol version as a string. Read only. Examples:
<code>'1.1'</code>, <code>'1.0'</code>.
Also <code>request.httpVersionMajor</code> is the first integer and
<code>request.httpVersionMinor</code> is the second.</p>

<p>只读的，以字符串形式表示HTTP协议版本。例如<code>'1.1'</code>，<code>'1.0'</code>。<code>request.httpVersionMajor</code>对应版本号的第一个数字，<code>request.httpVersionMinor</code>则对应第二个数字。 </p>

<h3 id="request.setEncoding">request.setEncoding(encoding=null)</h3>

<p>Set the encoding for the request body. Either <code>'utf8'</code> or <code>'binary'</code>. Defaults
to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>

<p>设置此请求正文的字符编码，<code>'utf8'</code>或者<code>'binary'</code>。缺省值是<code>null</code>，这表示<code>'data'</code>事件的参数将会是一个缓冲器对象。 </p>

<h3 id="request.pause">request.pause()</h3>

<p>Pauses request from emitting events.  Useful to throttle back an upload.</p>

<p>暂停此请求的事件触发。对于控制上传非常有用。 </p>

<h3 id="request.resume">request.resume()</h3>

<p>Resumes a paused request.</p>

<p>恢复一个暂停的请求。</p>

<h3 id="request.connection">request.connection</h3>

<p>The <code>net.Stream</code> object associated with the connection.</p>

<p>与当前连接相关联的<code>net.Stream</code>对象。</p>

<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client's
authentication details.</p>

<p>对于使用HTTPS的连接，可使用request.connection.verifyPeer()和request.connection.getPeerCertificate()来获得客户端的认证详情。 </p>

<h2 id="http.ServerResponse">http.ServerResponse</h2>

<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>'request'</code> event. It is a <code>Writable Stream</code>.</p>

<p>这个对象由HTTP服务器（而非用户）自动建立。它作为<code>'request'</code>事件的第二个参数，这是一个<code>Writable Stream</code>可写流。</p>

<h3 id="response.writeContinue">response.writeContinue()</h3>

<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the the <code>checkContinue</code> event on
<code>Server</code>.</p>

<p>发送HTTP/1.1 100 Continue消息给客户端，通知客户端可以发送请求的正文。参见服务器<code>Server</code>中的<code>checkContinue</code>事件。</p>

<h3 id="response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</h3>

<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.</p>

<p>这个方法用来发送一个响应头，statusCode是一个由3位数字所构成的HTTP状态码，比如<code>404</code>之类。最后一个参数<code>headers</code>是响应头具体内容。也可以使用一个方便人们直观理解的<code>reasonPhrase</code>作为第二个参数。 </p>

<p>Example:</p>

<pre><code>var body = 'hello world';
response.writeHead(200, {
  'Content-Length': body.length,
  'Content-Type': 'text/plain' });</code></pre>

<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.</p>

<p>在一次请求响应中此方法只能调用一次，并且必须在调用<code>response.end()</code>之前调用。 </p>

<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
implicit/mutable headers will be calculated and call this function for you.</p>

<p>如果你在<code>response.write()</code>或者<code>response.end()</code>之后调用此方法，响应头的内容将是不确定而且不可知的。</p>

<h3 id="response.statusCode">response.statusCode</h3>

<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property
controls the status code that will be send to the client when the headers get
flushed.</p>

<p>当隐式的发送响应头信息（没有明确调用<code>response.writeHead()</code>）时，使用此属性将设置返回给客户端的状态码。状态吗将在响应头信息发送时一起被发送。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>response.statusCode = 404;</code></pre>

<h3 id="response.setHeader">response.setHeader(name, value)</h3>

<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, it's value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.</p>

<p>在隐式的响应头基础上设置单个头信息。如果存在同名的待发送头信息，那么该头信息的值将被替换。如果你想发送相同名字的多个头部信息，可以使用字符串数组的形式设置。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>response.setHeader("Content-Type", "text/html");</code></pre>

<p>或者</p>

<pre><code>response.setHeader("Set-Cookie", ["type=ninja", "language=javascript"]);</code></pre>

<h3 id="response.getHeader">response.getHeader(name)</h3>

<p>Reads out a header that's already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.</p>

<p>读取已经排列好但尚未发送给客户端的头部信息，注意参数名不区分大小写。此方法必须在响应头信息隐式发送之前调用。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>var contentType = response.getHeader('content-type');</code></pre>

<h3 id="response.removeHeader">response.removeHeader(name)</h3>

<p>Removes a header that's queued for implicit sending.</p>

<p>移除等待隐式发送的头部信息。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>response.removeHeader("Content-Encoding");</code></pre>

<h3 id="response.write">response.write(chunk, encoding='utf8')</h3>

<p>If this method is called and <code>response.writeHead()</code> has not been called, it will
switch to implicit header mode and flush the implicit headers.</p>

<p>如果在<code>response.writeHead()</code>调用之前调用该函数，将会切换到隐式发送响应头信息的模式并发送隐式的头部信息。 </p>

<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.</p>

<p>它负责发送响应正文中的一部分数据，可以多次调用此方法以发送正文中多个连续的部分。</p>

<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>'utf8'</code>.</p>

<p><code>chunk</code>可以是一个字符串或者一个缓冲器。如果<code>chunk</code>是一个字符串，则第二个参数指定用何种编码方式将字符串编码为字节流。缺省情况下，<code>encoding</code>为<code>'utf8'</code>。 </p>

<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.</p>

<p><strong>注意</strong>：这是一个原始格式HTTP正文，和高层协议中的多段正文编码格式无关。 </p>

<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you're going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.</p>

<p>第一次调用<code>response.write()</code>时，此方法会将已经缓冲的消息头和第一块正文发送给客户。 当第二次调用<code>response.write()</code>的时候，Node将假定你想要逐次发送流数据。换句话说，响应被缓冲直到正文的第一块被发送。 </p>

<h3 id="response.addTrailers">response.addTrailers(headers)</h3>

<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.</p>

<p>该方法在响应中添加HTTP尾部头信息（在消息尾部的头信息）。</p>

<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.</p>

<p><strong>仅当</strong>响应报文使用chunked编码时，尾部信息才会发送；否则（例如请求的协议版本为HTTP/1.0）它们会被抛弃而没有提示。</p>

<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,</p>

<p>注意如果你想发送尾部信息，则需要在HTTP头中添加<code>Trailer</code>。</p>

<pre><code>response.writeHead(200, { 'Content-Type': 'text/plain',
                          'Trailer': 'TraceInfo' });
response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();</code></pre>

<h3 id="response.end">response.end([data], [encoding])</h3>

<p>This method signals to the server that all of the response headers and body
has been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.</p>

<p>这个方法通知服务器所有的响应头和响应正文都已经发出；服务器在此调用后认为这条信息已经发送完毕。在每个响应上都必须调用<code>response.end()</code>方法。 </p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.</p>

<p>如果指定了<code>data</code>参数，就相当先调用<code>response.write(data, encoding)</code>再调用<code>response.end()</code>。</p>

<h2 id="http.request">http.request(options, callback)</h2>

<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.</p>

<p>Node为一个目标服务器维护多个连接用于HTTP请求。通过这个方法可以向服务器发送请求。</p>

<p>Options:</p>

<p>选项：</p>

<ul><li><p><code>host</code>: A domain name or IP address of the server to issue the request to.
<code>host</code>: 请求的服务器域名或者IP地址。</p></li><li><p><code>port</code>: Port of remote server.
<code>port</code>: 远端服务器的端口。</p></li><li><p><code>method</code>: A string specifying the HTTP request method. Possible values:
<code>'GET'</code> (default), <code>'POST'</code>, <code>'PUT'</code>, and <code>'DELETE'</code>.
<code>method</code>: 指定HTTP请求的方法类型，可选的值有：<code>'GET'</code>（默认），<code>'POST'</code>，<code>'PUT'</code>，以及<code>'DELETE'</code>。</p></li><li><p><code>path</code>: Request path. Should include query string and fragments if any.
E.G. <code>'/index.html?page=12'</code>
<code>path</code>: 请求地址，可包含查询字符串以及可能存在的锚点。例如<code>'/index.html?page=12'</code>。</p></li><li><p><code>headers</code>: An object containing request headers.
<code>headers</code>: 一个包含请求头的对象。</p></li></ul>

<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>
class. The <code>ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code>ClientRequest</code> object.</p>

<p><code>http.request()</code>函数返回<code>http.ClientRequest</code>类的一个实例。<code>ClientRequest</code>对象是一个可写流，如果你需要用POST方法上传一个文件，可将其写入到<code>ClientRequest</code>对象中。</p>

<p>Example:</p>

<p>例子：</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST'
};

var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// write data to request body
req.write('data\n');
req.write('data\n');
req.end();</code></pre>

<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one
must always call <code>req.end()</code> to signify that you're done with the request -
even if there is no data being written to the request body.</p>

<p>注意这个例子中<code>req.end()</code>被调用了。无论请求正文是否包含数据，每一次调用<code>http.request()</code>最后都需要调用一次<code>req.end()</code>表示已经完成了请求。</p>

<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code>'error'</code> event is emitted
on the returned request object.</p>

<p>如果在请求过程中出现了错误（可能是DNS解析、TCP的错误、或者HTTP解析错误），返回的请求对象上的<code>'error'</code>的事件将被触发。</p>

<p>There are a few special headers that should be noted.</p>

<p>如下特别的消息头应当注意：</p>

<ul><li><p>Sending a 'Connection: keep-alive' will notify Node that the connection to
the server should be persisted until the next request.</p><p>发送'Connection: keep-alive'头部将通知Node此连接将保持到下一此请求。</p></li><li><p>Sending a 'Content-length' header will disable the default chunked encoding.</p><p>发送'Content-length'头将使默认的分块编码无效。</p></li><li><p>Sending an 'Expect' header will immediately send the request headers.
Usually, when sending 'Expect: 100-continue', you should both set a timeout
and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p><p>发送'Expect'头部将引起请求头部立即被发送。通常情况，当发送'Expect: 100-continue'时，你需要监听<code>continue</code>事件的同时设置超时。参见RFC2616 8.2.3章节以获得更多的信息。</p></li></ul>

<h2 id="http.get">http.get(options, callback)</h2>

<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code>http.request()</code> is
that it sets the method to GET and calls <code>req.end()</code> automatically.</p>

<p>由于大部分请求是不包含正文的GET请求，Node提供了这个方便的方法。与<code>http.request()</code>唯一的区别是此方法将请求方式设置为GET，并且自动调用<code>req.end()</code>。</p>

<p>Example:</p>

<p>例子：</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/index.html'
};

http.get(options, function(res) {
  console.log("Got response: " + res.statusCode);
}).on('error', function(e) {
  console.log("Got error: " + e.message);
});</code></pre>

<h2 id="http.Agent">http.Agent</h2>

<h2 id="http.getAgent">http.getAgent(host, port)</h2>

<p><code>http.request()</code> uses a special <code>Agent</code> for managing multiple connections to
an HTTP server. Normally <code>Agent</code> instances should not be exposed to user
code, however in certain situations it's useful to check the status of the
agent. The <code>http.getAgent()</code> function allows you to access the agents.</p>

<p><code>http.request()</code>使用一个特别的<code>Agent</code>代理来管理到一个服务器的多个连接，通常<code>Agent</code>对象不应该暴露给用户。但在某些特定的情况下，检测代理的状态是非常有用的。<code>http.getAgent()</code>函数允许你访问代理对象。</p>

<h3 id="event_upgrade_upgrade_">Event: 'upgrade' 事件：'upgrade'</h3>

<p><code>function (request, socket, head)</code></p>

<p>Emitted each time a server responds to a request with an upgrade. If this event
isn't being listened for, clients receiving an upgrade header will have their
connections closed.</p>

<p>当服务器响应upgrade请求时触发此事件。如果这个事件没有被监听，客户端接收到upgrade头会导致连接被关闭。</p>

<p>See the description of the <code>upgrade</code> event for <code>http.Server</code> for further details.</p>

<p>可以查看http.Server关于upgrade事件的解释来了解更多内容。 </p>

<h3 id="event_continue_continue_">Event: 'continue' 事件：'continue'</h3>

<p><code>function ()</code></p>

<p>Emitted when the server sends a '100 Continue' HTTP response, usually because
the request contained 'Expect: 100-continue'. This is an instruction that
the client should send the request body.</p>

<p>当服务器发送'100 Continue'答复时触发此事件，这通常是因为请求头信息中包含'Expect: 100-continue'。此事件指示客户端可是开始发送请求正文了。</p>

<h3 id="agent.maxSockets">agent.maxSockets</h3>

<p>By default set to 5. Determines how many concurrent sockets the agent can have open.</p>

<p>默认值为5，指定代理能同时并发打开的套接字数量。</p>

<h3 id="agent.sockets">agent.sockets</h3>

<p>An array of sockets currently in use by the Agent. Do not modify.</p>

<p>当前代理使用的套接字数组，不能更改。</p>

<h3 id="agent.queue">agent.queue</h3>

<p>A queue of requests waiting to be sent to sockets.</p>

<p>待发送到套接字的请求队列。</p>

<h2 id="http.ClientRequest">http.ClientRequest</h2>

<p>This object is created internally and returned from <code>http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The 
header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
<code>removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.</p>

<p>这个对象是在调用<code>http.request()</code>时产生并返回的。它表示一个<em>正在进行</em>中且头部信息已经排列好了的请求。这时候通过<code>setHeader(name, value)</code>，<code>getHeader(name)</code>，<code>removeHeader(name)</code>这些API还可以改变头部信息，实际的头部信息将随着第一块数据发送，或者在关闭连接时发送出去。</p>

<p>To get the response, add a listener for <code>'response'</code> to the request object.
<code>'response'</code> will be emitted from the request object when the response
headers have been received.  The <code>'response'</code> event is executed with one
argument which is an instance of <code>http.ClientResponse</code>.</p>

<p>为了获得响应，为请求对象增加一个对响应的监听器。</p>

<p>During the <code>'response'</code> event, one can add listeners to the
response object; particularly to listen for the <code>'data'</code> event. Note that
the <code>'response'</code> event is called before any part of the response body is received,
so there is no need to worry about racing to catch the first part of the
body. As long as a listener for <code>'data'</code> is added during the <code>'response'</code>
event, the entire body will be caught.</p>

<p>在<code>'response'</code>事件中，可以给响应对象添加监听器，特别是监听<code>'data'</code>事件，注意<code>'response'</code>事件在正文接收之前就已经被调用，所以不需要担心捕获不到正文的第一部分，一旦在<code>'response'</code>事件中添加了对<code>'data'</code>的监听器，那么整个正文将被捕获。</p>

<pre><code>// Good
request.on('response', function (response) {
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// Bad - misses all or part of the body
request.on('response', function (response) {
  setTimeout(function () {
    response.on('data', function (chunk) {
      console.log('BODY: ' + chunk);
    });
  }, 10);
});</code></pre>

<p>This is a <code>Writable Stream</code>.</p>

<p>这是一个<code>Writable Stream</code>可写流。</p>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<p>这是一个包含下述事件的<code>EventEmitter</code>事件触发器：</p>

<h3 id="event_response_response_">Event 'response' 事件：'response'</h3>

<p><code>function (response) { }</code></p>

<p>Emitted when a response is received to this request. This event is emitted only once. The
<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.</p>

<p>当请求的响应到达时触发，该事件仅触发一次。<code>response</code>参数是<code>http.ClientResponse</code>的一个实例。</p>

<h3 id="request.write">request.write(chunk, encoding='utf8')</h3>

<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>['Transfer-Encoding', 'chunked']</code> header line when
creating the request.</p>

<p>发送正文中的一块。用户可以通过多次调用这个方法将请求正文以流的方式发送到服务器。此种情况建议在建立请求时使用<code>['Transfer-Encoding', 'chunked']</code>请求头。 </p>

<p>The <code>chunk</code> argument should be an array of integers
or a string.</p>

<p>参数<code>chunk</code>应当是一个整数数组或字符串。 </p>

<p>The <code>encoding</code> argument is optional and only
applies when <code>chunk</code> is a string.</p>

<p>参数<code>encoding</code>是可选的，仅在<code>chunk</code>为字符串时可用。 </p>

<h3 id="request.end">request.end([data], [encoding])</h3>

<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>'0\r\n\r\n'</code>.</p>

<p>完成本次请求的发送。如果正文中的任何一个部分没有来得及发送，将把他们全部刷新到流中。如果本次请求是分块的，这个函数将发出结束字符<code>'0\r\n\r\n'</code>。 </p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>request.write(data, encoding)</code>
followed by <code>request.end()</code>.</p>

<p>如果使用参数data，就等于在调用request.write(data, encoding)之后紧接着调用request.end()。 </p>

<h3 id="request.abort">request.abort()</h3>

<p>Aborts a request.  (New since v0.3.8.)</p>

<p>阻止一个请求。（v0.3.8中新增的方法。）</p>

<h2 id="http.ClientResponse">http.ClientResponse</h2>

<p>This object is created when making a request with <code>http.request()</code>. It is
passed to the <code>'response'</code> event of the request object.</p>

<p>这个对象在使用<code>http.request()</code>发起请求时被创建，它会以参数的形式传递给request对象的<code>'response'</code>事件。 </p>

<p>The response implements the <code>Readable Stream</code> interface.</p>

<p>'response'实现了可读流的接口。</p>

<h3 id="event_data_data_">Event: 'data' 事件：'data'</h3>

<p><code>function (chunk) {}</code></p>

<p>Emitted when a piece of the message body is received.</p>

<p>当接收到消息正文一部分的时候触发。 </p>

<h3 id="event_end_end_">Event: 'end' 事件：'end'</h3>

<p><code>function () {}</code></p>

<p>Emitted exactly once for each message. No arguments. After
emitted no other events will be emitted on the response.</p>

<p>对每次消息请求只触发一次，该事件被触发后将不会再有任何事件在响应中被触发。</p>

<h3 id="response.statusCode">response.statusCode</h3>

<p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>

<p>3个数字组成的HTTP响应状态吗。例如<code>404</code>。</p>

<h3 id="response.httpVersion">response.httpVersion</h3>

<p>The HTTP version of the connected-to server. Probably either
<code>'1.1'</code> or <code>'1.0'</code>.
Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.</p>

<p>连接至服务器端的HTTP版本，可能的值为<code>'1.1'</code> or <code>'1.0'</code>，你也可以使用<code>response.httpVersionMajor</code>获得版本号第一位，使用<code>response.httpVersionMinor</code>获得版本号第二位。</p>

<h3 id="response.headers">response.headers</h3>

<p>The response headers object.</p>

<p>响应头部对象。</p>

<h3 id="response.trailers">response.trailers</h3>

<p>The response trailers object. Only populated after the 'end' event.</p>

<p>响应尾部对象，在'end'事件发生后填充该对象。</p>

<h3 id="response.setEncoding">response.setEncoding(encoding=null)</h3>

<p>Set the encoding for the response body. Either <code>'utf8'</code>, <code>'ascii'</code>, or <code>'base64'</code>.
Defaults to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>

<p>设置响应正文的编码，可以是<code>'utf8'</code>，<code>'ascii'</code>，或者<code>'base64'</code>。默认值为<code>null</code>，此种情况下<code>'data'</code>事件将发送缓冲器对象。</p>

<h3 id="response.pause">response.pause()</h3>

<p>Pauses response from emitting events.  Useful to throttle back a download.</p>

<p>暂停响应的事件激发，对控制下载流量非常有用。</p>

<h3 id="response.resume">response.resume()</h3>

<p>Resumes a paused response.</p>

<p>恢复一个已经暂停的响应。</p>

<p>﻿## HTTPS HTTPS模块</p>

<p>HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a
separate module.</p>

<p>HTTPS是基于TLS（Transport Layer Security 传输层安全）/SSL（Secure Sockets Layer 安全套接层）的HTTP协议，在Node中，它作为一个独立的模块被实现</p>

<h2 id="https.Server">https.Server</h2>

<h2 id="https.createServer">https.createServer</h2>

<p>Example:</p>

<p>例子：</p>

<pre><code>// curl -k https://localhost:8000/
var https = require('https');
var fs = require('fs');

var options = {
  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
};

https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end("hello world\n");
}).listen(8000);</code></pre>

<h2 id="https.request">https.request(options, callback)</h2>

<p>Makes a request to a secure web server.
Similar options to <code>http.request()</code>.</p>

<p>向安全的web服务器发送请求，可选参数和<code>http.request()</code>类似。</p>

<p>Example:</p>

<p>例子：</p>

<pre><code>var https = require('https');

var options = {
  host: 'encrypted.google.com',
  port: 443,
  path: '/',
  method: 'GET'
};

var req = https.request(options, function(res) {
  console.log("statusCode: ", res.statusCode);
  console.log("headers: ", res.headers);

  res.on('data', function(d) {
    process.stdout.write(d);
  });
});
req.end();

req.on('error', function(e) {
  console.error(e);
});</code></pre>

<p>The options argument has the following options</p>

<p>options参数可包含以下内容：</p>

<ul><li>host: IP or domain of host to make request to. Defaults to <code>'localhost'</code>.
host: 要访问的主机的IP地址或域名。默认为<code>'localhost'</code>。</li><li>port: port of host to request to. Defaults to 443.
port: 要访问的主机端口。默认为433。</li><li>path: Path to request. Default <code>'/'</code>.
path: 要访问的路径。默认为<code>'/'</code>。</li><li>method: HTTP request method. Default <code>'GET'</code>.
method: HTTP请求方式。默认为<code>'GET'</code>。</li><li>key: Private key to use for SSL. Default <code>null</code>.
key: SSL所使用的私钥。默认为<code>null</code>。</li><li>cert: Public x509 certificate to use. Default <code>null</code>.
cert: 所使用的x509公钥证书。默认为<code>null</code>。</li><li>ca: An authority certificate or array of authority certificates to check
the remote host against.
ca: 用于验证远程主机身份的一个认证中心证书（或多个认证中心证书数组）。</li></ul>

<h2 id="https.get">https.get(options, callback)</h2>

<p>Like <code>http.get()</code> but for HTTPS.</p>

<p>类似<code>http.get()</code>但它基于HTTPS协议。</p>

<p>Example:</p>

<p>例子：</p>

<pre><code>var https = require('https');

https.get({ host: 'encrypted.google.com', path: '/' }, function(res) {
  console.log("statusCode: ", res.statusCode);
  console.log("headers: ", res.headers);

  res.on('data', function(d) {
    process.stdout.write(d);
  });

}).on('error', function(e) {
  console.error(e);
});</code></pre>

<h2 id="uRL_URL_">URL URL模块</h2>

<p>This module has utilities for URL resolution and parsing.
Call <code>require('url')</code> to use it.</p>

<p>此模块包含用于解析和分析URL的工具。可通过<code>require('url')</code>访问他们。</p>

<p>Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL</p>

<p>解析后的URL对象包含下述部分或全部字段。具体包含哪些字段取决于解析前的URL字符串中是否存在这些字段。在原始的URL字符串中不存在的字段在解析后的对象中也不会包含。以下面这个URL为例：</p>

<p><code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p>

<ul><li><p><code>href</code>: The full URL that was originally parsed.</p><p><code>href</code>：完整的原始URL字符串。</p><p>Example: <code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p><p>例如：<code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p></li><li><p><code>protocol</code>: The request protocol.</p><p><code>protocol</code>：请求所使用的协议。</p><p>Example: <code>'http:'</code></p><p>例如：<code>'http:'</code></p></li><li><p><code>host</code>: The full host portion of the URL, including port and authentication information.</p><p><code>host</code>：URL中关于主机的完整信息，包括端口以及用户身份验证信息。</p><p>Example: <code>'user:pass@host.com:8080'</code></p><p>例如：<code>'user:pass@host.com:8080'</code></p></li><li><p><code>auth</code>: The authentication information portion of a URL.</p><p><code>auth</code>：URL中的用户身份验证信息。</p><p>Example: <code>'user:pass'</code></p><p>例如：<code>'user:pass'</code></p></li><li><p><code>hostname</code>: Just the hostname portion of the host.</p><p><code>hostname</code>：主机信息中的主机名部分。</p><p>Example: <code>'host.com'</code></p><p>例如：<code>'host.com'</code></p></li><li><p><code>port</code>: The port number portion of the host.</p><p><code>port</code>：主机信息中的端口部分。</p><p>Example: <code>'8080'</code></p><p>例如：<code>'8080'</code></p></li><li><p><code>pathname</code>: The path section of the URL, that comes after the host and before the query, including the initial slash if present.</p><p><code>pathname</code>：URL中的路径部分，这部分信息位于主机信息之后查询字符串之前。如果存在最上层根目录符号<code>'/'</code>，也将包含在此信息中。</p><p>Example: <code>'/p/a/t/h'</code></p><p>例如：<code>'/p/a/t/h'</code></p></li><li><p><code>search</code>: The 'query string' portion of the URL, including the leading question mark.</p><p><code>search</code>：URL中的'query string'（查询字符串）部分，包括前导的<code>'?'</code>。</p><p>Example: <code>'?query=string'</code></p><p>例如：<code>'?query=string'</code></p></li><li><p><code>query</code>: Either the 'params' portion of the query string, or a querystring-parsed object.</p><p><code>query</code>：查询字符串中的参数部分，或者是由查询字符串解析出的对象。</p><p>Example: <code>'query=string'</code> or <code>{'query':'string'}</code></p><p>例如：<code>'query=string'</code> or <code>{'query':'string'}</code></p></li><li><p><code>hash</code>: The 'fragment' portion of the URL including the pound-sign.</p><p><code>hash</code>：URL中的锚点部分，包含前导的<code>'#'</code>。</p><p>Example: <code>'#hash'</code></p><p>例如：<code>'#hash'</code></p></li></ul>

<p>The following methods are provided by the URL module:</p>

<p>URL模块提供了如下方法：</p>

<h3 id="url.parse">url.parse(urlStr, parseQueryString=false)</h3>

<p>Take a URL string, and return an object.  Pass <code>true</code> as the second argument to also parse
the query string using the <code>querystring</code> module.</p>

<p>以一个 URL字符串为参数，返回一个解析后的对象。如设置第二个参数为<code>true</code>，则会使用<code>querystring</code>模块解析URL中的查询字符串。</p>

<h3 id="url.format">url.format(urlObj)</h3>

<p>Take a parsed URL object, and return a formatted URL string.</p>

<p>以一个解析后的URL对象为参数，返回格式化的URL字符串。</p>

<h3 id="url.resolve">url.resolve(from, to)</h3>

<p>Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag.</p>

<p>指定一个默认URL地址，和一个链接的目标URL地址，返回链接的绝对URL地址。处理方式与浏览器处理锚点标签的方法一致。
## Query String 查询字符串模块</p>

<p>This module provides utilities for dealing with query strings.
It provides the following methods:</p>

<p>该模块为处理查询字符串提供了一些实用的功能。包括如下的方法：</p>

<h3 id="querystring.stringify">querystring.stringify(obj, sep='&amp;', eq='=')</h3>

<p>Serialize an object to a query string.
Optionally override the default separator and assignment characters.</p>

<p>将一个对象序列化为一个查询字符串，可选择是否覆盖默认的分隔符和赋值符。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>querystring.stringify({foo: 'bar'})
// returns
'foo=bar'

querystring.stringify({foo: 'bar', baz: 'bob'}, ';', ':')
// returns
'foo:bar;baz:bob'</code></pre>

<h3 id="querystring.parse">querystring.parse(str, sep='&amp;', eq='=')</h3>

<p>Deserialize a query string to an object.
Optionally override the default separator and assignment characters.</p>

<p>将一个查询字符串反序列化为一个对象，可选择是否覆盖默认的分隔符和赋值符。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>querystring.parse('a=b&amp;b=c')
// returns
{ a: 'b', b: 'c' }</code></pre>

<h3 id="querystring.escape">querystring.escape</h3>

<p>The escape function used by <code>querystring.stringify</code>,
provided so that it could be overridden if necessary.</p>

<p>由<code>querystring.stringify</code>使用的转义函数，需要时可重置其内容。</p>

<h3 id="querystring.unescape">querystring.unescape</h3>

<p>The unescape function used by <code>querystring.parse</code>,
provided so that it could be overridden if necessary.</p>

<p>由<code>querystring.parse</code>使用的反转义函数，需要时可重置其内容。</p>

<h2 id="rEPL_">REPL 交互式解释器</h2>

<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily
includable in other programs.  REPL provides a way to interactively run
JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.</p>

<p>交互式解释器（REPL）既可以作为一个独立的程序运行，也可以很容易地包含在其他程序中作为整体程序的一部分使用。REPL为运行JavaScript脚本与查看运行结果提供了一种交互方式，通常REPL交互方式可以用于调试、测试以及试验某种想法。</p>

<p>By executing <code>node</code> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.</p>

<p>在命令行中不带任何参数地运行<code>node</code>命令，就可以进入REPL环境，在该环境下你可以进行一些类似Emacs的行编辑操作。</p>

<pre><code>mjr:~$ node
Type '.help' for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>

<p>For advanced line-editors, start node with the environmental variable <code>NODE_NO_READLINE=1</code>.
This will start the REPL in canonical terminal settings which will allow you to use with <code>rlwrap</code>.</p>

<p>为了进行高级的行编辑操作，可以设置环境变量<code>NODE_NO_READLINE=1</code>并启动node。这种情况REPL会进入标准终端设置模式，这此模式下你可以使用<code>rlwrap</code>。</p>

<p>For example, you could add this to your bashrc file:</p>

<p>比如，你可以把下列设置添加到你的bashrc文件中：</p>

<pre><code>alias node="env NODE_NO_READLINE=1 rlwrap node"</code></pre>

<h3 id="repl.start">repl.start(prompt='&gt; ', stream=process.stdin)</h3>

<p>Starts a REPL with <code>prompt</code> as the prompt and <code>stream</code> for all I/O.  <code>prompt</code>
is optional and defaults to <code>&gt; </code>.  <code>stream</code> is optional and defaults to
<code>process.stdin</code>.</p>

<p>启动一个REPL，使用<code>prompt</code>作为输入提示符，在<code>stream</code>上进行所有I/O操作。<code>prompt</code>是可选参数，默认值为<code>&gt; </code>，<code>stream</code>也是可选参数，默认值为<code>process.stdin</code>。</p>

<p>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.</p>

<p>一个node实例中可以启动多个REPL，它们共享相同的全局对象，但拥有各自独立的I/O。</p>

<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:</p>

<p>下面是的例子展示分别在标准输入，Unix套接字及TCP套接字上启动的REPL示例：</p>

<pre><code>var net = require("net"),
    repl = require("repl");

connections = 0;

repl.start("node via stdin&gt; ");

net.createServer(function (socket) {
  connections += 1;
  repl.start("node via Unix socket&gt; ", socket);
}).listen("/tmp/node-repl-sock");

net.createServer(function (socket) {
  connections += 1;
  repl.start("node via TCP socket&gt; ", socket);
}).listen(5001);</code></pre>

<p>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful
for connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and
TCP sockets.</p>

<p>在命令行中运行这段程序将首先使用标准输入启动REPL。其他的REPL终端可以通过Unix套接字或者TCP套接字进行连接。可使用<code>telnet</code>程序连接到TCP套接字，而<code>socat</code>程序既可以连接到Unix套接字也可以连接连接到TCP套接字。</p>

<p>By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.</p>

<p>若要连接到一个长时间运行的node进程而无需重启进程，你应该将REPL启动在Unix套接字上，非不要将其启动在标准输出上。</p>

<h3 id="rEPL_Features_REPL_">REPL Features REPL特性</h3>

<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.</p>

<p>在REPL中，操作组合键Control+D可以退出。可以输入多行表达式。</p>

<p>The special variable <code>_</code> (underscore) contains the result of the last expression.</p>

<p>特殊变量<code>_</code>（下划线）包含了上一表达式的结果。</p>

<pre><code>&gt; [ "a", "b", "c" ]
[ 'a', 'b', 'c' ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>

<p>The REPL provides access to any variables in the global scope. You can expose a variable
to the REPL explicitly by assigning it to the <code>context</code> object associated with each
<code>REPLServer</code>.  For example:</p>

<p>在REPL可以访问全局作用域中的任何变量。为了在REPL中访问一个变量，你只要将此变量显性地分配给相应<code>REPLServer</code>的<code>context</code>对象。示例如下：</p>

<pre><code>// repl_test.js
var repl = require("repl"),
    msg = "message";

repl.start().context.m = msg;</code></pre>

<p>Things in the <code>context</code> object appear as local within the REPL:</p>

<p><code>context</code>对象中的变量在REPL中看起来就像是本地变量。</p>

<pre><code>mjr:~$ node repl_test.js
&gt; m
'message'</code></pre>

<p>There are a few special REPL commands:</p>

<p>以下是另外一些特殊的REPL命令：</p>

<ul><li><code>.break</code> - While inputting a multi-line expression, sometimes you get lost
or just don't care about completing it. <code>.break</code> will start over.
<code>.break</code> - 当你输入多行表达式，如果想放弃当前的输入，可以用<code>.break</code>跳出。</li><li><code>.clear</code> - Resets the <code>context</code> object to an empty object and clears any multi-line expression.
<code>.clear</code> - 将<code>context</code>重置为空对象，并清空当前正在输入的多行表达式。</li><li><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.
<code>.exit</code> - 该命令用于关闭I/O流，并退出REPL。</li><li><code>.help</code> - Show this list of special commands.
<code>.help</code> - 输出特殊命令的列表。</li></ul>

<h2 id="child_Processes_">Child Processes  子进程</h2>

<p>Node provides a tri-directional <code>popen(3)</code> facility through the <code>ChildProcess</code>
class.</p>

<p>在Node里，<code>ChildProcess</code>类提供了一个3向的<code>popen(3)</code>机制。</p>

<p>It is possible to stream data through the child's <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code> in a fully non-blocking way.</p>

<p>子进程类中的<code>stdin</code>， <code>stdout</code>，和<code>stderr</code> 可以使数据流以完全非阻塞式的方式（non-blocking way）流动（stream）</p>

<p>To create a child process use <code>require('child_process').spawn()</code>.</p>

<p>调用<code>require('child_process').spawn()</code>可以创建一个子进程（child process） </p>

<p>Child processes always have three streams associated with them. <code>child.stdin</code>,
<code>child.stdout</code>, and <code>child.stderr</code>.</p>

<p><code>child.stdin</code>，<code>child.stdout</code>，和 <code>child.stderr</code>等3个流总是伴随着子进程。</p>

<p><code>ChildProcess</code> is an <code>EventEmitter</code>.</p>

<p><code>ChildProcess</code> 是一种 <code>EventEmitter</code>（事件触发器）。</p>

<h3 id="event_exit_exit_">Event:  'exit' 事件：'exit'</h3>

<p><code>function (code, signal) {}</code></p>

<p>This event is emitted after the child process ends. If the process terminated
normally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If
the process terminated due to receipt of a signal, <code>signal</code> is the string name
of the signal, otherwise <code>null</code>.</p>

<p>当子进程结束时，（Node）触发该事件。如果进程正常终结，那么进程的最终退出代码（ final exit code）为<code>code</code>，否则为<code>null</code>。如果进程的结束是因为接收到一个信号，那么<code>signal</code>为string型的信号名称，否则为<code>null</code>。</p>

<p>See <code>waitpid(2)</code>.</p>

<p>参见<code>waitpid(2)</code>。</p>

<h3 id="child.stdin">child.stdin</h3>

<p>A <code>Writable Stream</code> that represents the child process's <code>stdin</code>.
Closing this stream via <code>end()</code> often causes the child process to terminate.</p>

<p>一个<code>Writable Stream</code>（可写流），表示子进程的<code>stdin</code>。调用<code>end()</code>来关闭这个流通常会终结整个子进程。</p>

<h3 id="child.stdout">child.stdout</h3>

<p>A <code>Readable Stream</code> that represents the child process's <code>stdout</code>.</p>

<p>一个<code>Readable Stream</code>（可读流），表示子进程的<code>stdout</code>（标准输出）。</p>

<h3 id="child.stderr">child.stderr</h3>

<p>A <code>Readable Stream</code> that represents the child process's <code>stderr</code>.</p>

<p>一个<code>Readable Stream</code>（可读流），表示子进程的<code>stderr</code>（标准错误）。</p>

<h3 id="child.pid">child.pid</h3>

<p>The PID of the child process.</p>

<p>子进程的PID（进程编号）。</p>

<p>Example:</p>

<p>例如：</p>

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

console.log('Spawned child pid: ' + grep.pid);
grep.stdin.end();</code></pre>

<h3 id="child_process.spawn">child_process.spawn(command, args=[], [options])</h3>

<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.
If omitted, <code>args</code> defaults to an empty Array.</p>

<p>使用指定的<code>command</code>创建一个新进程，命令行参数为<code>args</code>。缺省下，<code>args</code>默认为一个空数组。</p>

<p>The third argument is used to specify additional options, which defaults to:</p>

<p>第三个参数用于指定附加的选项，默认如下：</p>

<pre><code>{ cwd: undefined,
  env: process.env,
  customFds: [-1, -1, -1],
  setsid: false
}</code></pre>

<p><code>cwd</code> allows you to specify the working directory from which the process is spawned.
Use <code>env</code> to specify environment variables that will be visible to the new process.
With <code>customFds</code> it is possible to hook up the new process' [stdin, stout, stderr] to
existing streams; <code>-1</code> means that a new stream should be created. <code>setsid</code>,
if set true, will cause the subprocess to be run in a new session.</p>

<p>参数<code>cwd</code>允许你指定要创建的子进程的工作目录(working directory)。参数<code>env</code>可以指定哪些环境变量在新进程中是可见的。参数<code>customFds</code>可以使新进程中的[stdin, stout, stderr]和已存在的流进行挂接（hook up）。参数<code>-1</code>可以建立一个新的流。如果设置参数<code>setsid</code>为true，该子进程将转入到一个新会话（session）中运行。</p>

<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:</p>

<p>例：运行<code>ls -lh /usr</code>命令，捕获<code>stdout</code>，<code>stderr</code>和退出代码：</p>

<pre><code>var util   = require('util'),
    spawn = require('child_process').spawn,
    ls    = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', function (data) {
  console.log('stdout: ' + data);
});

ls.stderr.on('data', function (data) {
  console.log('stderr: ' + data);
});

ls.on('exit', function (code) {
  console.log('child process exited with code ' + code);
});</code></pre>

<p>Example: A very elaborate way to run 'ps ax | grep ssh'</p>

<p>例：运行'ps ax | grep ssh'命令的完整方法：</p>

<pre><code>var util   = require('util'),
    spawn = require('child_process').spawn,
    ps    = spawn('ps', ['ax']),
    grep  = spawn('grep', ['ssh']);

ps.stdout.on('data', function (data) {
  grep.stdin.write(data);
});

ps.stderr.on('data', function (data) {
  console.log('ps stderr: ' + data);
});

ps.on('exit', function (code) {
  if (code !== 0) {
    console.log('ps process exited with code ' + code);
  }
  grep.stdin.end();
});

grep.stdout.on('data', function (data) {
  console.log(data);
});

grep.stderr.on('data', function (data) {
  console.log('grep stderr: ' + data);
});

grep.on('exit', function (code) {
  if (code !== 0) {
    console.log('grep process exited with code ' + code);
  }
});</code></pre>

<p>Example of checking for failed exec:</p>

<p>检测exec执行是否失败的例子：</p>

<pre><code>var spawn = require('child_process').spawn,
    child = spawn('bad_command');

child.stderr.on('data', function (data) {
  if (/^execvp\(\)/.test(data.asciiSlice(0,data.length))) {
    console.log('Failed to start child process.');
  }
});</code></pre>

<p>See also: <code>child_process.exec()</code></p>

<p>可参见：<code>child_process.exec()</code></p>

<h3 id="child_process.exec">child_process.exec(command, [options], callback)</h3>

<p>High-level way to execute a command as a child process, buffer the
output, and return it all in a callback.</p>

<p>以子进程方式执行一个命令的高级方法。所有输出经过缓冲后在同一个回调函数中返回。</p>

<pre><code>var util   = require('util'),
    exec  = require('child_process').exec,
    child;

child = exec('cat *.js bad_file | wc -l',
  function (error, stdout, stderr) {
    console.log('stdout: ' + stdout);
    console.log('stderr: ' + stderr);
    if (error !== null) {
      console.log('exec error: ' + error);
    }
});</code></pre>

<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>
will be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>err.code</code>
will be the exit code of the child process, and <code>err.signal</code> will be set to the
signal that terminated the process.</p>

<p>回调函数获得<code>(error, stdout, stderr)</code>3个参数。成功时，<code>error</code>为<code>null</code>。错误时<code>error</code>为一个<code>Error</code>实例，<code>err.code</code>为该子进程的退出代码，<code>err.signal</code>为使该进程结束的信号。</p>

<p>There is a second optional argument to specify several options. The default options are</p>

<p>可选的第二个参数用于指定一些选项。默认选项如下：</p>

<pre><code>{ encoding: 'utf8',
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: 'SIGTERM',
  cwd: null,
  env: null }</code></pre>

<p>If <code>timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code>timeout</code> milliseconds. The child process is killed with
<code>killSignal</code> (default: <code>'SIGTERM'</code>). <code>maxBuffer</code> specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.</p>

<p>如果参数<code>timeout</code>的值超过0，那么当运行超过<code>timeout</code>毫秒后子进程将终止。<code>killSignal</code> 为终止子进程的信号(默认为： <code>'SIGTERM'</code>)。 参数<code>maxBuffer</code>指定了stdout或stderr流最大数据量，一旦超过该值，子进程将会终止。</p>

<h3 id="child.kill">child.kill(signal='SIGTERM')</h3>

<p>Send a signal to the child process. If no argument is given, the process will
be sent <code>'SIGTERM'</code>. See <code>signal(7)</code> for a list of available signals.</p>

<p>给子进程发送信号。如果没有指定参数，（Node）将会发送<code>'SIGTERM'</code>信号。在<code>signal(7)</code> 中可查阅到可用的信号列表。</p>

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

grep.on('exit', function (code, signal) {
  console.log('child process terminated due to receipt of signal '+signal);
});

// send SIGHUP to process
grep.kill('SIGHUP');</code></pre>

<p>Note that while the function is called <code>kill</code>, the signal delivered to the child
process may not actually kill it.  <code>kill</code> really just sends a signal to a process.</p>

<p>注意：虽然函数名为<code>kill</code>（杀死），发送的信号并不会真正杀死子进程。<code>kill</code>仅仅是向该进程发送一个信号。</p>

<p>See <code>kill(2)</code></p>

<p>参见<code>kill(2)</code></p>

<h2 id="assert_">Assert  断言模块</h2>

<p>This module is used for writing unit tests for your applications, you can
access it with <code>require('assert')</code>.</p>

<p>断言（Assert）模块用于为应用编写单元测试，可以通过<code>require('assert')</code>对该模块进行调用。</p>

<h3 id="assert.fail">assert.fail(actual, expected, message, operator)</h3>

<p>Tests if <code>actual</code> is equal to <code>expected</code> using the operator provided.</p>

<p>使用指定操作符测试<code>actual</code>（真实值）是否和<code>expected</code>（期望值）一致。</p>

<h3 id="assert.ok">assert.ok(value, [message])</h3>

<p>Tests if value is a <code>true</code> value, it is equivalent to <code>assert.equal(true, value, message);</code></p>

<p>测试实际值是否为<code>true</code>，和<code>assert.equal(true, value, message);</code>作用一致</p>

<h3 id="assert.equal">assert.equal(actual, expected, [message])</h3>

<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ).</p>

<p>使用等值比较操作符( <code>==</code> )测试真实值是否浅层地（shallow），强制性地（coercive）和预期值相等。</p>

<h3 id="assert.notEqual">assert.notEqual(actual, expected, [message])</h3>

<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).</p>

<p>使用不等比较操作符( <code>!=</code> )测试真实值是否浅层地（shallow），强制性地（coercive）和预期值不相等。</p>

<h3 id="assert.deepEqual">assert.deepEqual(actual, expected, [message])</h3>

<p>Tests for deep equality.</p>

<p>测试真实值是否深层次地和预期值相等。</p>

<h3 id="assert.notDeepEqual">assert.notDeepEqual(actual, expected, [message])</h3>

<p>Tests for any deep inequality.</p>

<p>测试真实值是否深层次地和预期值不相等。</p>

<h3 id="assert.strictEqual">assert.strictEqual(actual, expected, [message])</h3>

<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> )</p>

<p>使用严格相等操作符 ( <code>===</code> )测试真实值是否严格地（strict）和预期值相等。</p>

<h3 id="assert.notStrictEqual">assert.notStrictEqual(actual, expected, [message])</h3>

<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> )</p>

<p>使用严格不相等操作符 ( <code>!==</code> )测试真实值是否严格地（strict）和预期值不相等。</p>

<h3 id="assert.throws">assert.throws(block, [error], [message])</h3>

<p>Expects <code>block</code> to throw an error. <code>error</code> can be constructor, regexp or 
validation function.</p>

<p>预期<code>block</code>时抛出一个错误（error）， <code>error</code>可以为构造函数，正则表达式或者其他验证器。</p>

<p>Validate instanceof using constructor:</p>

<p>使用构造函数验证实例：</p>

<pre><code>assert.throws(
  function() {
    throw new Error("Wrong value");
  },
  Error
);</code></pre>

<p>Validate error message using RegExp:</p>

<p>使用正则表达式验证错误信息：</p>

<pre><code>assert.throws(
  function() {
    throw new Error("Wrong value");
  },
  /value/
);</code></pre>

<p>Custom error validation:</p>

<p>用户自定义的错误验证器：</p>

<pre><code>assert.throws(
  function() {
    throw new Error("Wrong value");
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  "unexpected error"
);</code></pre>

<h3 id="assert.doesNotThrow">assert.doesNotThrow(block, [error], [message])</h3>

<p>Expects <code>block</code> not to throw an error, see assert.throws for details.</p>

<p>预期<code>block</code>时不抛出错误，详细信息请见assert.throws。</p>

<h3 id="assert.ifError">assert.ifError(value)</h3>

<p>Tests if value is not a false value, throws if it is a true value. Useful when
testing the first argument, <code>error</code> in callbacks.</p>

<p>测试值是否不为false，当为true时抛出。常用于回调中第一个参数<code>error</code>的测试。
## TTY 终端模块</p>

<p>Use <code>require('tty')</code> to access this module.</p>

<p>可使用<code>require('tty')</code>访问此模块。</p>

<p>Example:</p>

<p>示例：</p>

<pre><code>var tty = require('tty');
tty.setRawMode(true);
process.stdin.resume();
process.stdin.on('keypress', function(char, key) {
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == 'c') {
    console.log('graceful exit');
    process.exit()
  }
});</code></pre>

<h3 id="tty.open">tty.open(path, args=[])</h3>

<p>Spawns a new process with the executable pointed to by <code>path</code> as the session
leader to a new pseudo terminal.</p>

<p>用<code>path</code>路径所指向的可执行文件启动一个新的进程，并将其作为一个新的伪终端的控制进程。</p>

<p>Returns an array <code>[slaveFD, childProcess]</code>. <code>slaveFD</code> is the file descriptor
of the slave end of the pseudo terminal. <code>childProcess</code> is a child process
object.</p>

<p>返回一个数组 <code>[slaveFD, childProcess]</code>。<code>slaveFD</code> 是这个伪终端的从设备文件描述符，<code>childProcess</code>是子进程的对象。</p>

<h3 id="tty.isatty">tty.isatty(fd)</h3>

<p>Returns <code>true</code> or <code>false</code> depending on if the <code>fd</code> is associated with a
terminal.</p>

<p>当<code>fd</code>所表示的文件描述符与一个终端相关联时返回<code>true</code>，否则返回<code>false</code>。</p>

<h3 id="tty.setRawMode">tty.setRawMode(mode)</h3>

<p><code>mode</code> should be <code>true</code> or <code>false</code>. This sets the properties of the current
process's stdin fd to act either as a raw device or default.</p>

<p><code>mode</code>参数可以设为<code>true</code>或<code>false</code>。此方法设置当前进程的stdin（标准输入）为原始设备方式，或默认方式。</p>

<h3 id="tty.setWindowSize">tty.setWindowSize(fd, row, col)</h3>

<p><code>ioctl</code>s the window size settings to the file descriptor.</p>

<p>使用<code>ioctl</code>设置文件描述符对应的终端窗口大小（行数与列数）。</p>

<h3 id="tty.getWindowSize">tty.getWindowSize(fd)</h3>

<p>Returns <code>[row, col]</code> for the TTY associated with the file descriptor.</p>

<p>返回文件描述符所对应的终端的窗口大小<code>[row, col]</code>（行数与列数）。</p>

<h2 id="os_Module_">os Module 操作系统模块</h2>

<p>Use <code>require('os')</code> to access this module.</p>

<p>可以通过<code>require('os')</code>访问这个os 模块。</p>

<h3 id="os.hostname">os.hostname()</h3>

<p>Returns the hostname of the operating system.</p>

<p>该方法返回当前操作系统的主机名。</p>

<h3 id="os.type">os.type()</h3>

<p>Returns the operating system name.</p>

<p>该方法返回当前操作系统名称。</p>

<h3 id="os.release">os.release()</h3>

<p>Returns the operating system release.</p>

<p>返回当前操作系统的发型版本。</p>

<h3 id="os.uptime">os.uptime()</h3>

<p>Returns the system uptime in seconds.</p>

<p>该方法返回当前系统的正常运行时间，时间以秒为单位。</p>

<h3 id="os.loadavg">os.loadavg()</h3>

<p>Returns an array containing the 1, 5, and 15 minute load averages.</p>

<p>该方法返回一个数组，该数组存储着系统1分钟，5分钟，以及15分钟的负载均值。</p>

<h3 id="os.totalmem">os.totalmem()</h3>

<p>Returns the total amount of system memory in bytes.</p>

<p>返回系统存储空间总值，该值以字节（byte）为单位。</p>

<h3 id="os.freemem">os.freemem()</h3>

<p>Returns the amount of free system memory in bytes.</p>

<p>返回系统存储的剩余空间，该值以字节（byte）为单位。</p>

<h3 id="os.cpus">os.cpus()</h3>

<p>Returns an array of objects containing information about each CPU/core installed: model, speed (in MHz), and times (an object containing the number of 
CPU ticks spent in: user, nice, sys, idle, and irq).</p>

<p>该方法返回一个对象数组，该数组包含了关于系统每个CPU/内核的信息：型号，速度（以MHz为单位），以及CPU时间使用情况（包含CPU时间片在用户态、改变过优先级的用户进程、内核态、空闲、以及IRQ各方面的消耗）。</p>

<p>Example inspection of os.cpus:</p>

<p>os.cpus以一个示例如下:</p>

<pre><code>[ { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>

<h2 id="debugger_">Debugger 调试器</h2>

<p>V8 comes with an extensive debugger which is accessible out-of-process via a
simple <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP protocol</a>.
Node has a built-in client for this debugger. To use this, start Node with the
<code>debug</code> argument; a prompt will appear:</p>

<p>V8引擎自身配备了全面的调试器，该调试器通过简单的<a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP协议</a>在进程外访问。Node中内置了该调试器的客户端，要使用它可以在启动Node时附加<code>debug</code>参数，此模式下将显示debug提示符：</p>

<pre><code>% node debug myscript.js
debug&gt;</code></pre>

<p>At this point <code>myscript.js</code> is not yet running. To start the script, enter
the command <code>run</code>. If everything works okay, the output should look like
this:</p>

<p>此时 <code>myscript.js</code>还没有开始执行，若要执行这段脚本，还需要输入<code>run</code>命令。如果一切运行正常的话输出信息应该如下所示：</p>

<pre><code>% node debug myscript.js
debug&gt; run
debugger listening on port 5858
connecting...ok</code></pre>

<p>Node's debugger client doesn't support the full range of commands, but
simple step and inspection is possible. By putting the statement <code>debugger;</code>
into the source code of your script, you will enable a breakpoint.</p>

<p>Node的调试器客户端虽然没有支持所有的命令，但是实现简单的单步调试还是可以的。你可以在脚本代码中声明<code>debugger;</code>语句从而启用一个断点。</p>

<p>For example, suppose <code>myscript.js</code> looked like this:</p>

<p>例如，假设<code>myscript.js</code>代码如下：</p>

<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log("world");
}, 1000);
console.log("hello");</code></pre>

<p>Then once the debugger is run, it will break on line 4.</p>

<p>一旦调试器开始运行，那么它将在执行到第4行代码处时停止。</p>

<pre><code>% ./node debug myscript.js
debug&gt; run
debugger listening on port 5858
connecting...ok
hello
break in #&lt;an Object&gt;._onTimeout(), myscript.js:4
  debugger;
  ^
debug&gt; next
break in #&lt;an Object&gt;._onTimeout(), myscript.js:5
  console.log("world");
  ^
debug&gt; print x
5
debug&gt; print 2+2
4
debug&gt; next
world
break in #&lt;an Object&gt;._onTimeout() returning undefined, myscript.js:6
}, 1000);
^
debug&gt; quit
A debugging session is active. Quit anyway? (y or n) y
%</code></pre>

<p>The <code>print</code> command allows you to evaluate variables. The <code>next</code> command steps
over to the next line. There are a few other commands available and more to
come type <code>help</code> to see others.</p>

<p><code>print</code>命令允许将变量输出到控制台进行查看。<code>next</code>命令单步调试到下一行代码。还有其他一些可用的命令你可以通过输入<code>help</code>进行查看。</p>

<h3 id="advanced_Usage_">Advanced Usage 高级用法</h3>

<p>The V8 debugger can be enabled and accessed either by starting Node with
the <code>--debug</code> command-line flag or by signaling an existing Node process
with <code>SIGUSR1</code>.</p>

<p>要启用V8引擎调试器你可以在启动Node时增加命令行参数<code>--debug</code>或者给一个已经存在的Node进程发送值为<code>SIGUSR1</code>的信号量。</p>

<h1>Appendixes 附录</h1>

<h2 id="appendix_1_Third_Party_Modules_1_">Appendix 1 - Third Party Modules  附录 1 - 第三方模块</h2>

<p>There are many third party modules for Node. At the time of writing, August
2010, the master repository of modules is
<a href="http://github.com/ry/node/wiki/modules">the wiki page</a>.</p>

<p>Node中包含许多第三方模块。截至撰写时（2010年8月），<a href="http://github.com/ry/node/wiki/modules">此wiki页</a>是存放Node模块的主仓库。</p>

<p>This appendix is intended as a SMALL guide to new-comers to help them
quickly find what are considered to be quality modules. It is not intended
to be a complete list.  There may be better more complete modules found
elsewhere.</p>

<p>本附录的编写目的在于简要指导Node的新用户，帮助他们可以迅速找到公认的优秀Node模块。这里并非一份完整的列表，在其他地方也许可以找到其他更好更完善的模块。</p>

<ul><li><p>Module Installer: <a href="http://github.com/isaacs/npm">npm</a></p><p>模块安装：<a href="http://github.com/isaacs/npm">npm</a> </p></li><li><p>HTTP Middleware: <a href="http://github.com/senchalabs/connect">Connect</a></p><p>HTTP中间件（Middleware）：<a href="http://github.com/senchalabs/connect">Connect</a></p></li><li><p>Web Framework: <a href="http://github.com/visionmedia/express">Express</a></p><p>Web框架：<a href="http://github.com/visionmedia/express">Express</a></p></li><li><p>Web Sockets: <a href="http://github.com/LearnBoost/Socket.IO-node">Socket.IO</a></p></li><li><p>HTML Parsing: <a href="http://github.com/aredridel/html5">HTML5</a></p><p>HTML解析器：<a href="http://github.com/aredridel/html5">HTML5</a></p></li><li><p><a href="http://github.com/agnat/node_mdns">mDNS/Zeroconf/Bonjour</a></p></li><li><p><a href="http://github.com/ry/node-amqp">RabbitMQ, AMQP</a></p></li><li><p><a href="http://github.com/felixge/node-mysql">mysql</a></p></li><li><p>Serialization: <a href="http://github.com/pgriess/node-msgpack">msgpack</a></p><p>序列化工具：<a href="http://github.com/pgriess/node-msgpack">msgpack</a></p></li><li><p>Scraping: <a href="http://github.com/silentrob/Apricot">Apricot</a></p><p>抓取器：<a href="http://github.com/silentrob/Apricot">Apricot</a></p></li><li><p>Debugger: <a href="http://github.com/smtlaissezfaire/ndb">ndb</a> is a CLI debugger
<a href="http://github.com/dannycoates/node-inspector">inspector</a> is a web based
tool.</p><p>调试工具：<a href="http://github.com/smtlaissezfaire/ndb">ndb</a>是一个CLI调试工具
<a href="http://github.com/dannycoates/node-inspector">inspector</a>是一个基于Web的调试工具</p></li><li><p><a href="http://github.com/mranney/node_pcap">pcap binding</a></p></li><li><p><a href="http://github.com/mscdex/node-ncurses">ncurses</a></p></li><li><p>Testing/TDD/BDD: <a href="http://vowsjs.org/">vows</a>,
<a href="http://github.com/visionmedia/expresso">expresso</a>,
<a href="http://github.com/tmpvar/mjsunit.runner">mjsunit.runner</a></p><p>测试工具/TDD/BDD： <a href="http://vowsjs.org/">vows</a>,
<a href="http://github.com/visionmedia/expresso">expresso</a>,
<a href="http://github.com/tmpvar/mjsunit.runner">mjsunit.runner</a></p></li></ul>

<p>Patches to this list are welcome.</p>

<p>欢迎大家对本列表进行补充。</p>
  </div>
  <script type="text/javascript" src="res/sh_main.js"></script>
  <script type="text/javascript" src="res/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
</body>
</html>
